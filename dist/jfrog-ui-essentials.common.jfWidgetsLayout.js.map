{"version":3,"sources":["webpack://jfrog-ui-essentials/src/components/JfWidgetsLayoutComponent/index.vue","webpack://jfrog-ui-essentials/./src/components/JfWidgetsLayoutComponent/index.vue?c21f","webpack://jfrog-ui-essentials/./src/components/JfWidgetsLayoutComponent/index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AA2CA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,oBADA;AAEA,2BAFA;AAGA,UACA,SADA,EAEA,QAFA,EAGA,SAHA,EAIA,YAJA,EAKA,YALA,CAHA;AAUA,gBACA,QADA,EAEA,YAFA,EAGA,UAHA,EAIA,UAJA,EAKA,IALA,EAMA,kBANA,EAOA,MAPA,EAQA,WARA,EASA,UATA,CAVA;AAqBA,MArBA,kBAqBA;AACA;AACA,wBADA;AAEA,qBAFA;AAGA,6BAHA;AAIA,oBAJA;AAKA,oBALA;AAMA,sBANA;AAOA,eAPA;AAQA,gBARA;AASA;AATA;AAWA,GAjCA;AAkCA,SAlCA,qBAkCA;AACA;AACA,GApCA;AAqCA,SArCA,qBAqCA;AAAA;;AACA;;AAEA;AACA,mBACA;;AACA;;AACA;;AACA;;AACA;;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AACA,OANA,MAMA;AACA;AACA,wCACA;AACA,SAHA;;AAIA;AACA;AAAA;AAAA;AACA,SAFA;AAGA;AACA,KAtBA;;AAuBA;AACA;;AACA;;AAEA;AACA;;AACA;AACA;;AAEA;AACA,6DACA;AACA;AACA;AACA;AACA;;AACA;AACA,KAjBA;AAmBA;AAEA;AACA;AACA;AACA;AACA,KAJA;;AAMA;AACA;AACA;;AAEA;AACA,wBACA;AAAA;AAAA;AACA,KAHA;AAIA,GAlGA;AAmGA;AACA,gBADA,wBACA,OADA,EACA;AACA;AACA,KAHA;AAIA;AAJA,GAnGA;AAyGA;AACA,qBADA,+BACA;AACA,yBACA;AACA,iCACA;AACA,mCACA;AACA,mCACA;AACA,kDACA;AACA,mDACA;AACA,+CACA;AAEA;AACA;AACA;AACA;AACA,KArBA;AAsBA,mBAtBA,6BAsBA;AAAA;;AAEA;AACA;AACA;AACA,uBACA;AACA,uBACA;AACA,OAPA;;AAQA;AACA;AACA,sBACA;AACA,OAJA;;AAKA;AACA;AACA,sBACA;AACA,OAJA;;AAMA;AAEA;;AAEA;AACA;AACA,OAFA,MAEA;AACA;AACA,OAFA,MAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA,gDADA;AAEA,+EAFA;AAGA,yCAHA;AAIA;AAJA;;AAMA;AACA;AACA;AACA,aAFA;AAGA;;AACA;AACA,SAhBA;;AAiBA;AACA,OApBA;AAsBA;AAEA,KAhFA;AAiFA,mBAjFA,6BAiFA;AAAA;;AACA;AACA;AACA;AACA;AACA,SAFA;AAGA,OAJA;AAKA,KAxFA;AAyFA,iBAzFA,2BAyFA;AAAA;;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA,eALA,EAKA,OALA,CAKA;AACA,4BADA,CAEA;;AACA;AACA;AACA;AACA;AACA,eAZA;AAaA,aAfA,MAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAzBA;AA0BA,OA3BA;AA6BA,kBACA;AACA;AACA,KAnIA;AAoIA,aApIA,uBAoIA;AAAA;;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA,wCACA,aADA,KAEA,mCACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AAEA;AACA,+BADA;AAEA,gCAFA;AAGA,oEAHA;AAIA,kEAJA;AAKA,sDALA;AAMA;AANA;;AASA;AACA;AACA,mDACA;AACA,WAJA,MAIA;AACA;AACA,kDACA;AACA;AAEA,SA3BA;AA4BA,wCACA,oBADA,KAEA,mCACA;AACA,OAtCA;AAwCA;AACA;AACA,uBADA;AAEA,wBAFA;AAGA,0BAHA;AAIA;AAJA;AAOA;AACA,mDADA;AAEA,kDAFA;AAGA;AAHA;AAMA,+BACA;AACA,KAnMA;AAoMA,mBApMA,6BAoMA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA,kBADA;AAEA,iBAFA;AAGA,yBAHA;AAIA,0BAJA;AAKA,yBALA;AAMA;AANA;AAQA;AACA;AACA;AAEA,KAzNA;AA0NA,mBA1NA,6BA0NA;AAAA;;AACA;AACA,uBACA;AAAA;AAAA;AACA;;AACA;AACA;AACA;;AACA;AAAA;AACA;;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAAA,gBAAgB;AAAhB;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA,4CACA,6BAnCA,CAqCA;;AACA;;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA,aAFA;AA5CA;AAgDA;AACA;AACA,KApRA;AAqRA,kBArRA,0BAqRA,EArRA,EAqRA;AACA;AACA;AACA,KAxRA;AAyRA,sBAzRA,8BAyRA,EAzRA,EAyRA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA,oBACA;AACA;;AAEA;AACA,KApSA;AAqSA,kBArSA,0BAqSA,QArSA,EAqSA;AACA;AAAA;AAAA;AACA,KAvSA;AAwSA,iBAxSA,yBAwSA,CAxSA,EAwSA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA,gBADA;AAEA;AAFA;AAIA,KAxTA;AAyTA,eAzTA,uBAyTA,CAzTA,EAyTA;AAEA,uDACA;;AAEA;AACA;AACA;AACA,OAHA,MAGA;AAEA;;AAEA;;AACA;;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA,WAHA,MAGA;AACA;AACA;AACA,WAHA,MAGA;AACA;AACA;AACA,WAHA,MAGA;AACA;AACA;AACA;;AACA;AACA,SAlBA,MAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,KAjWA;AAkWA,gBAlWA,wBAkWA,CAlWA,EAkWA;AACA,uDACA;AACA;AACA;AACA,KAvWA;AAwWA,UAxWA,kBAwWA,CAxWA,EAwWA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA,SAPA,MAOA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA,SAPA,MAOA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA,SAPA,MAOA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,kDACA;AAEA;;AACA;AACA;;AACA;AACA,WAHA,MAGA;AACA;;AACA;AACA,WAHA,MAGA;AACA;;AACA;AACA,WAHA,MAGA;AACA;;AACA;AACA;AACA;AACA;AAEA,KAjbA;AAkbA,sBAlbA,8BAkbA,IAlbA,EAkbA,CAlbA,EAkbA;AAEA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA,KAtcA;AAucA,eAvcA,uBAucA,CAvcA,EAucA;AAEA,uDACA;;AAEA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA,KApdA;AAqdA,aArdA,qBAqdA,CArdA,EAqdA;AACA,uDACA;AAEA;AACA;AACA;AACA;AACA;AAEA,aACA;AAEA,KAleA;AAmeA,qBAneA,6BAmeA,CAneA,EAmeA;AACA,uDACA;AACA,yDACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA,KA9eA;AA+eA,oBA/eA,4BA+eA,IA/eA,EA+eA;AACA;AACA,mBADA;AAEA,mBAFA;AAGA,mBAHA;AAIA,mBAJA;AAKA,+BALA;AAMA,2BANA;AAOA;AAPA;AASA;AACA,mBADA;AAEA,mBAFA;AAGA,mBAHA;AAIA,mBAJA;AAKA,+BALA;AAMA,2BANA;AAOA;AAPA;AASA;AACA,mBADA;AAEA,mBAFA;AAGA,mBAHA;AAIA,mBAJA;AAKA,+BALA;AAMA,2BANA;AAOA;AAPA;AASA;AACA,mBADA;AAEA,mBAFA;AAGA,mBAHA;AAIA,mBAJA;AAKA,+BALA;AAMA,2BANA;AAOA;AAPA;AASA,KAphBA;AAqhBA,mBArhBA,2BAqhBA,CArhBA,EAqhBA,CArhBA,EAqhBA;AAAA;;AACA;AAEA;AAEA;;AACA;AACA,cADA;AAEA;AAFA,WAGA,IAHA,EAGA,QAHA;;AAIA,uBACA;AACA,OATA;AAWA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA,qBADA;AAEA;AAFA;;AAKA;AACA;AACA;AAAA;AAAA;AACA;AACA,OAVA;AAWA;AACA;AAAA;AAAA;AACA,qBADA;AAEA;AAFA;;AAKA;AACA;AACA;AAAA;AAAA;AACA;AACA,OAVA;AAYA;AACA,KAlkBA;AAmkBA,sBAnkBA,8BAmkBA,EAnkBA,EAmkBA,IAnkBA,EAmkBA,YAnkBA,EAmkBA;AACA;AACA,0BACA,gCADA,KAEA,oBACA;AACA,oBADA;AAEA;AAFA,WADA,KAKA,oBACA;AACA,oBADA;AAEA;AAFA,WADA,KAMA;AACA,OAfA,MAeA;AACA,0BACA;AACA,4BACA;AACA,oBADA;AAEA;AAFA,WADA,KAKA,oBACA;AACA,oBADA;AAEA;AAFA,WADA,KAMA;AACA;AACA,KAnmBA;AAomBA,uBApmBA,+BAomBA,GApmBA,EAomBA,GApmBA,EAomBA;AACA;AACA,KAtmBA;AAumBA,kBAvmBA,0BAumBA,MAvmBA,EAumBA;AACA;;AACA;AACA;AACA;AACA;AACA,KA7mBA;AA8mBA,oBA9mBA,8BA8mBA;AAAA;AACA;AACA,kBACA,6DADA,KAGA;AACA,KApnBA;AAqnBA,gBArnBA,wBAqnBA,SArnBA,EAqnBA;AACA;;AAEA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA,OARA;;AASA;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;AACA;AACA,KA7oBA;AA8oBA,kBA9oBA,4BA8oBA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAJA;AAKA;;AACA;AACA;AACA;AACA;AACA,aAFA,MAEA;AACA;AACA;AACA,WANA;AAOA;AACA,OAlBA;;AAmBA;AACA;AACA;AACA;AACA;AACA,aAFA,MAEA;AACA;AACA;AACA,WANA;AAOA,SARA;AASA;AACA,KA9qBA;AA+qBA,aA/qBA,qBA+qBA,SA/qBA,EA+qBA,WA/qBA,EA+qBA;AAAA;;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WANA,MAMA;AACA;AACA;AACA;AACA;AACA,0BADA;AAEA,8CAFA;AAGA;AAHA;AAKA;AACA;AACA,OArBA;AAuBA;AACA,KAzsBA;AA0sBA,eA1sBA,yBA0sBA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA,OAFA;AAGA,KAltBA;AAmtBA,gBAntBA,wBAmtBA,SAntBA,EAmtBA;AACA;AACA;AACA,KAttBA;AAutBA,kBAvtBA,0BAutBA,SAvtBA,EAutBA;AACA;AACA;AACA;AACA,KA3tBA;AA4tBA,iBA5tBA,yBA4tBA,GA5tBA,EA4tBA;AACA;AACA,KA9tBA;AA+tBA,oBA/tBA,8BA+tBA;AAAA;;AACA,mCACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA,uCACA;AACA,wCACA;AAEA;AACA;AACA,2DACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA,SAtBA;;AAwBA;AACA,OA3BA;AA6BA,KArwBA;AAswBA,mBAtwBA,6BAswBA;AACA;AACA,KAxwBA;AAywBA,mBAzwBA,2BAywBA,MAzwBA,EAywBA;AACA;AACA;AACA,OAFA,MAEA;AACA;AACA;AACA,KA/wBA;AAgxBA,qBAhxBA,+BAgxBA;AACA,gCACA,YADA,KAGA;AACA,KArxBA;AAsxBA,eAtxBA,yBAsxBA;AACA,mCACA,OAFA,CAIA;;AACA;AACA;AAAA;AAAA;AACA;AACA,OAHA,CAKA;AALA,WAMA;AAEA;AAAA;AAAA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA,WAJA,MAIA;AACA;AACA;AACA;AACA;AACA,OAdA,CAgBA;AAhBA,WAiBA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA,KA7zBA;AA8zBA,cA9zBA,sBA8zBA,SA9zBA,EA8zBA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA,sCADA;AAEA;AAFA;;AAIA;AACA;AACA,aAFA,MAEA;AACA;AACA;;AACA;AACA;AACA;AACA,eAHA,MAGA;AACA;AACA;AACA;AACA;AACA,WAlBA,MAkBA;AACA;AACA;AACA;AACA;AACA,SAxBA;AAyBA,OA1BA;;AA4BA;AACA;AACA;AACA,SAFA,EAEA,yBAFA;AAGA,OAJA,MAIA;AACA;AACA;AACA;AACA;AACA;AACA,aAFA;AAGA,WAJA;AAMA,SAPA,EAOA,yBAPA;AAQA;;AAEA;AACA;AACA;;AAEA;AAEA;AAl3BA;AAzGA,G;;ACrD8U,CAAgB,gJAAG,EAAC,C;;;;;ACAlW;AACyD;AACL;;;AAGpD;AAC6F;AAC7F,gBAAgB,8CAAU;AAC1B,EAAE,2DAAM;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEe,+G","file":"jfrog-ui-essentials.common.jfWidgetsLayout.js","sourcesContent":["<script>\n\n    const TEMPLATE = `\n    <div>\n        <div class=\"jf-widgets-layout-container\"  :style=\"containerCss\" @mouseleave=\"onMouseLeave($event)\" @mousemove=\"onMouseMove($event)\" @mousedown=\"onMouseDown($event)\" @mouseup=\"onMouseUp($event)\">\n            <div class=\"widgets-padder\" :style=\"padderCss\">\n                <div v-for=\"rowOrColumn in transformedLayout\" class=\"widgets-row\">\n                    <div v-for=\"layoutObj in rowOrColumn\" :style=\"cssRules[layoutObj.cssId]\" class=\"widget-wrapper\" :class=\"{['widget-wrapper-' + widgets[layoutObj.widget].id.toLowerCase()]: true, 'atom': !layoutObj.subLayout}\">\n                        <div v-if=\"!layoutObj.subLayout && editMode\" class=\"edit-mode-actions\" @mousemove=\"onWidgetMouseMove($event)\">\n                            <i class=\"glyphicon glyphicon-asterisk\" v-jf-tooltip=\"'Change'\" @click=\"changeWidget(layoutObj)\"></i>\n                            <i class=\"glyphicon glyphicon-remove-circle\" v-jf-tooltip=\"'Remove'\" v-if=\"getWidgetsCount() > 1\" @click=\"removeWidget(layoutObj)\"></i>\n                            <i class=\"glyphicon glyphicon-resize-vertical\" v-jf-tooltip=\"'Vertical Split'\" @click=\"splitCell(layoutObj,'v')\"></i>\n                            <i class=\"glyphicon glyphicon-resize-horizontal\" v-jf-tooltip=\"'Horizontal Split'\" @click=\"splitCell(layoutObj,'h')\"></i>\n                        </div>\n                        <div v-if=\"!layoutObj.subLayout && editMode && layoutObj.selectWidgetMode\" class=\"select-widget-mode\" @mousemove=\"onWidgetMouseMove($event)\">\n                            <div class=\"widget-selector\">\n                                <jf-ui-select :jf-select-model=\"layoutObj.widget\" jf-select-display-func=\"getWidgetName($item)\" jf-select-placeholder=\"Select A Widget\" jf-select-change=\"onWidgetChange(layoutObj)\" :jf-select-options=\"widgetKeys\"></jf-ui-select>\n                            </div>\n                        </div>\n                        <div v-if=\"!layoutObj.subLayout && (_getRootDirective().transformedLayout.length > 1 || _getRootDirective().transformedLayout[0].length > 1) && options.expandablePanes\" :style=\"{top: top, left: left}\" class=\"expansion-corner-mask\">\n                            <div class=\"expansion-corner-fill\" @click=\"expandPane(layoutObj)\">\n                                <div class=\"icon icon-thin-arrow\" :class=\"{expanded: layoutObj.expanded}\"></div>\n                            </div>\n                        </div>\n                        <div class=\"widget-container\" @mousemove=\"onWidgetMouseMove($event)\" v-if=\"!layoutObj.subLayout\" :style=\"{overflow: widgets[layoutObj.widget].scroll ? 'auto' : 'hidden'}\">\n                            <div v-if=\"widgets[layoutObj.widget] && widgets[layoutObj.widget].showSpinner\" class=\"widget-spinner\">\n                                <div class=\"spinner-msg\">\n                                    <div class=\"icon-hourglass\"></div>\n                                </div>\n                            </div>\n                            <div v-if=\"widgets[layoutObj.widget] && widgets[layoutObj.widget].template\" v-show=\"widgets[layoutObj.widget].$compiled || (!widgets[layoutObj.widget].model && !widgets[layoutObj.widget].controller)\">\n                                <div class=\"compile-children\" v-show=\"widgets[layoutObj.widget].$compiled\" :id=\"layoutObj.widget\" v-html=\"widgets[layoutObj.widget].template\"></div>\n                            </div>\n                        </div>\n                        <div v-if=\"layoutObj.subLayout\">\n                            <jf-widgets-layout :layout=\"layoutObj.subLayout\" :widgets=\"widgets\" :options=\"subOptions\" parent-cell=\"layoutObj\"></jf-widgets-layout>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            <div id=\"home-disclaimer\" v-html=\"footerText\" v-if=\"footerText\"></div>\n        </div>\n    </div>\n    `;\n\n    import extend from 'lodash/extend';\n    import includes from 'lodash/includes';\n    import map from 'lodash/map';\n    import cloneDeep from 'lodash/cloneDeep';\n    import indexOf from 'lodash/indexOf';\n    import filter from 'lodash/filter';\n    import find from 'lodash/find';\n\n    export default {\n        template: TEMPLATE,\n        name: 'jf-widgets-layout',\n        props: [\n            'widgets',\n            'layout',\n            'options',\n            'parentCell',\n            'footerText'\n        ],\n        'jf@inject': [\n            '$scope',\n            '$rootScope',\n            '$compile',\n            '$timeout',\n            '$q',\n            '$templateRequest',\n            '$sce',\n            '$injector',\n            '$element'\n        ],\n        data() {\n            return {\n                containerCss: null,\n                padderCss: null,\n                transformedLayout: null,\n                cssRules: null,\n                editMode: null,\n                widgetKeys: null,\n                top: null,\n                left: null,\n                subOptions: null\n            };\n        },\n        created() {\n            this.ANIM_DURATION = 0.5;\n        },\n        mounted() {\n            this.setDefaultOptions();\n\n            let onChange = (newval, oldval) => {\n                if (!newval)\n                    return;\n                this.transformLayout();\n                this.updateFlatCells();\n                this.updateCss();\n                this.updateDragLines();\n                if (this.recompile) {\n                    this.recompile = false;\n                    Object.keys(this.widgets).forEach(id => delete this.widgets[id].$compiled);\n                    this.templatesLoadStarted = false;\n                    this.templatesLoaded = false;\n                    this.$timeout(() => this.compileElements());\n                } else if (!this.templatesLoadStarted || this.templatesLoaded) {\n                    Object.keys(this.widgets).forEach(id => {\n                        if (this._isWidgetInUse(id))\n                            delete this.widgets[id].$compiled;\n                    });\n                    this.loadTemplates().then(() => {\n                        this.$timeout(() => this.compileElements());\n                    });\n                }\n            };\n            this.$scope.$watch('jfWidgetsLayout.options.editMode', editMode => {\n                this.editMode = editMode === undefined ? false : editMode;\n                this.$set(this.subOptions, 'editMode', this.editMode);\n\n                if (!editMode) {\n                    this.cleanLayout();\n                    if (!this.options.isSub) {\n                        this.updateLayoutJSON();\n\n                        if (this.wasEditing) {\n                            if (this.options.onEditEnd && this.layoutJSON)\n                                this.options.onEditEnd(this.layoutJSON);\n                            this.recompile = true;\n                        }\n                    }\n                }\n                this.wasEditing = this.editMode;\n            });\n\n            this.$scope.$watch('jfWidgetsLayout.layout', onChange);\n\n            this.$scope.$watch('jfWidgetsLayout.widgets', widgets => {\n                if (widgets) {\n                    this.widgetKeys = Object.keys(widgets);\n                }\n            });\n\n            if (this.options.parent && this.parentCell) {\n                this.$set(this.parentCell, '$childLayout', this);\n            }\n\n            this.$scope.$on('$destroy', () => {\n                if (this.scopes)\n                    this.scopes.forEach(s => s.$destroy());\n            });\n        },\n        ng1_legacy: {\n            ng1compileFn(element) {\n                return recursiveDirective.compile(element);\n            },\n            'controllerAs': 'jfWidgetsLayout'\n        },\n        methods: {\n            setDefaultOptions() {\n                if (!this.options)\n                    this.options = {};\n                if (!this.options.padding)\n                    this.$set(this.options, 'padding', 10);\n                if (!this.options.minHeight)\n                    this.$set(this.options, 'minHeight', 'initial');\n                if (!this.options.backColor)\n                    this.$set(this.options, 'backColor', 'transparent');\n                if (this.options.allowResize === undefined)\n                    this.$set(this.options, 'allowResize', false);\n                if (this.options.outerPadding === undefined)\n                    this.$set(this.options, 'outerPadding', true);\n                if (this.options.editMode === undefined)\n                    this.$set(this.options, 'editMode', false);\n\n                this.subOptions = cloneDeep(this.options);\n                this.$set(this.subOptions, 'minHeight', 'initial');\n                this.$set(this.subOptions, 'isSub', true);\n                this.$set(this.subOptions, 'parent', this);\n            },\n            transformLayout() {\n\n                let _getSizeFromCell = cell => {\n                    let i1 = cell.indexOf('%');\n                    let i2 = cell.indexOf('px');\n                    if (i1 !== -1)\n                        return cell.substr(0, i1);\n                    if (i2 !== -1)\n                        return cell.substr(0, i2);\n                };\n                let _getWidgetNameFromCell = cell => {\n                    let i = cell.indexOf('@');\n                    if (i !== -1)\n                        return cell.substr(i + 1);\n                };\n                let _getSubLayoutFromCell = cell => {\n                    let i = cell.indexOf('#');\n                    if (i !== -1)\n                        return cell.substr(i + 1);\n                };\n\n                this.transformedLayout = [];\n\n                let theLayout = this.layout.main || this.layout;\n\n                if (theLayout.rows) {\n                    this.mainAxis = 'rows';\n                } else if (theLayout.columns) {\n                    this.mainAxis = 'columns';\n                } else {\n                    console.log('Layout Format Error! Must have rows or columns.');\n                    return;\n                }\n\n                theLayout[this.mainAxis].forEach(rowOrColumn => {\n                    let tRowOrColumn = [];\n                    rowOrColumn.cells.forEach(cell => {\n                        let height = this.mainAxis === 'rows' ? rowOrColumn.size : _getSizeFromCell(cell);\n                        let width = this.mainAxis === 'columns' ? rowOrColumn.size : _getSizeFromCell(cell);\n                        let subLayoutName = _getSubLayoutFromCell(cell);\n                        let tCell = {\n                            widget: _getWidgetNameFromCell(cell),\n                            subLayout: subLayoutName ? this.layout[subLayoutName] : undefined,\n                            percentWidth: parseInt(width),\n                            percentHeight: parseInt(height)\n                        };\n                        if (rowOrColumn.new) {\n                            this.$timeout(() => {\n                                this.splitCell(tCell, this.mainAxis === 'columns' ? 'v' : 'h');\n                            });\n                        }\n                        tRowOrColumn.push(tCell);\n                    });\n                    this.transformedLayout.push(tRowOrColumn);\n                });\n\n                this.normalizeSizes();\n\n            },\n            updateFlatCells() {\n                this.flatCells = [];\n                this.transformedLayout.forEach(rowOrColumn => {\n                    rowOrColumn.forEach(cell => {\n                        this.flatCells.push(cell);\n                    });\n                });\n            },\n            loadTemplates() {\n                let defer = this.$q.defer();\n\n                if (this.templatesLoaded) {\n                    defer.resolve();\n                    return defer.promise;\n                }\n\n                this.templatesLoadStarted = true;\n                let fired = 0, completed = 0;\n                this.transformedLayout.forEach(rowOrColumn => {\n                    rowOrColumn.forEach(layoutDef => {\n                        let widget = this.widgets[layoutDef.widget];\n                        if (widget) {\n                            if (widget.templateUrl && !widget.template) {\n                                fired++;\n                                this.$templateRequest(widget.templateUrl).then(template => {\n                                    if (!widget.$templateLoaded) {\n                                        widget.template = this.$sce.trustAsHtml(template);\n                                        widget.$templateLoaded = true;\n                                    }\n                                }).finally(() => {\n                                    completed++;\n                                    //                            console.log('completed ' + completed + ' out of ' + fired);\n                                    if (fired === completed) {\n                                        this.templatesLoaded = true;\n                                        defer.resolve();\n                                    }\n                                });\n                            } else if (widget.template) {\n                                if (!widget.$templateLoaded) {\n                                    widget.template = this.$sce.trustAsHtml(widget.template);\n                                    widget.$templateLoaded = true;\n                                }\n                            }\n                        }\n                    });\n                });\n\n                if (!fired)\n                    defer.resolve();\n                return defer.promise;\n            },\n            updateCss() {\n                let oldRules = cloneDeep(this.cssRules);\n                this.cssRules = {};\n\n                let currentX = 0, currentY = 0;\n                let cssRunningId = 0;\n\n                this.transformedLayout.forEach(rowOrColumn => {\n                    if (this.mainAxis === 'rows')\n                        currentX = 0;\n                    else if (this.mainAxis === 'columns')\n                        currentY = 0;\n                    let topSize = 0;\n                    rowOrColumn.forEach(layoutDef => {\n                        let widget = this.widgets[layoutDef.widget];\n                        layoutDef.cssId = cssRunningId;\n                        if (!widget) {\n                            layoutDef.widget = '$widget' + cssRunningId;\n                        }\n                        cssRunningId++;\n\n                        this.cssRules[layoutDef.cssId] = {\n                            top: currentY + '%',\n                            left: currentX + '%',\n                            bottom: 100 - (currentY + layoutDef.percentHeight) + '%',\n                            right: 100 - (currentX + layoutDef.percentWidth) + '%',\n                            padding: this.options.padding / 2 + 'px',\n                            opacity: oldRules && oldRules[layoutDef.cssId] && oldRules[layoutDef.cssId].opacity !== undefined ? oldRules[layoutDef.cssId].opacity : 1\n                        };\n\n                        if (this.mainAxis === 'rows') {\n                            currentX += layoutDef.percentWidth;\n                            if (layoutDef.percentHeight > topSize)\n                                topSize = layoutDef.percentHeight;\n                        } else if (this.mainAxis === 'columns') {\n                            currentY += layoutDef.percentHeight;\n                            if (layoutDef.percentWidth > topSize)\n                                topSize = layoutDef.percentWidth;\n                        }\n\n                    });\n                    if (this.mainAxis === 'rows')\n                        currentY += topSize;\n                    else if (this.mainAxis === 'columns')\n                        currentX += topSize;\n                });\n\n                let pad = this.options.isSub ? 0 : this.options.outerPadding ? this.options.padding / 2 : -this.options.padding / 2;\n                this.padderCss = {\n                    top: pad + 'px',\n                    left: pad + 'px',\n                    bottom: pad + 'px',\n                    right: pad + 'px'\n                };\n\n                this.containerCss = {\n                    'min-height': this.options.minHeight + 'px',\n                    'background-color': this.options.backColor,\n                    'overflow': this.options.isSub && this.editMode ? 'visible' : 'hidden'\n                };\n\n                if (this.options.parent)\n                    this.options.parent.updateCss();\n            },\n            updateDragLines() {\n                this.dragLines = [];\n                for (let key in this.cssRules) {\n                    let rules = this.cssRules[key];\n                    let top = parseFloat(rules.top);\n                    let bottom = parseFloat(rules.bottom);\n                    let left = parseFloat(rules.left);\n                    let right = parseFloat(rules.right);\n                    let cell = find(this.flatCells, { cssId: parseInt(key) });\n                    this.addLinesFromRect({\n                        x1: left,\n                        y1: top,\n                        x2: 100 - right,\n                        y2: 100 - bottom,\n                        cssRules: rules,\n                        widget: cell.widget\n                    });\n                    cell.percentWidth = 100 - right - left;\n                    cell.percentHeight = 100 - bottom - top;\n                }\n\n            },\n            compileElements() {\n                let elems = $('.compile-children');\n                if (this.scopes)\n                    this.scopes.forEach(s => s.$destroy());\n                this.scopes = [];\n                for (let i = 0; i < elems.length; i++) {\n                    let elem = $(elems[i]);\n                    let widgetId = elem.prop('id');\n                    if (this._isWidgetInUse(widgetId)) {\n                        let widget = this._getWidgetById(widgetId);\n                        let scope = this.$rootScope.$new();\n\n                        this.scopes.push(scope);\n\n                        let children = elem.children();\n\n                        if (widget.model) {\n                            extend(scope, widget.model);\n                        }\n                        if (this.options.sharedModel) {\n                            extend(scope, this.options.sharedModel);\n                        }\n                        if (!widget.controller) {\n                            widget.controller = class Ctrl {\n                            };\n                        }\n\n                        widget.controller.prototype.$widgetLayoutManager = this;\n\n                        let controllerInstance = this.$injector.instantiate(widget.controller);\n\n                        controllerInstance.$element = children[0];\n                        controllerInstance.$layoutObject = this._getLayoutByWidget(elem.prop('id'));\n                        controllerInstance.$scope = scope;\n                        controllerInstance.$widgetObject = widget;\n\n                        let controllerObject = {};\n                        controllerObject[widget.controllerAs || 'ctrl'] = controllerInstance;\n\n                        extend(scope, controllerObject);\n\n\n                        if (controllerInstance.$onInit)\n                            controllerInstance.$onInit();\n\n                        //We compile only first child, templates should have only one root element!\n                        let rootChild = $(children[0]);\n                        if (!rootChild.prop('compiled')) {\n                            this.$compile(rootChild)(scope);\n                            rootChild.prop('compiled', true);\n                        }\n\n                        this.$timeout(() => {\n                            widget.$compiled = true;\n                        });\n\n                    }\n                }\n            },\n            _getWidgetById(id) {\n                let widget = this.widgets[id];\n                return widget;\n            },\n            _getLayoutByWidget(id) {\n                let layout;\n\n                for (let i in this.transformedLayout) {\n                    let rowOrColumn = this.transformedLayout[i];\n                    layout = find(rowOrColumn, { widget: id });\n                    if (layout)\n                        break;\n                }\n\n                return layout;\n            },\n            _isWidgetInUse(widgetId) {\n                return !!find(this.flatCells, { widget: widgetId });\n            },\n            _getPrecPoint(e) {\n                let container = $(this.$element).find('.jf-widgets-layout-container');\n\n                let containerWidth = container.innerWidth();\n                let containerHeight = container.innerHeight();\n\n                let mouseX = e.pageX - container.offset().left;\n                let mouseY = e.pageY - container.offset().top;\n\n                let xprec = Math.round(mouseX / containerWidth * 100);\n                let yprec = Math.round(mouseY / containerHeight * 100);\n\n                return {\n                    x: xprec,\n                    y: yprec\n                };\n            },\n            onMouseMove(e) {\n\n                if (!this.options.allowResize && !this.editMode)\n                    return;\n\n                if (this.draggingLines) {\n                    this.onDrag(e);\n                    e.preventDefault();\n                } else {\n\n                    let container = $(this.$element).find('.jf-widgets-layout-container');\n\n                    let prec = this._getPrecPoint(e);\n                    this.closestLines = this.getClosestLines(prec.x, prec.y);\n                    if (this.closestLines.length) {\n                        let directions = map(this.closestLines, 'cssRelevantRule');\n\n                        let cursor;\n                        if (includes(directions, 'right') && includes(directions, 'left') && includes(directions, 'top') && includes(directions, 'bottom')) {\n                            cursor = 'all-scroll';\n                            this.setSubIsOnEdge(true);\n                        } else if (includes(directions, 'top') && includes(directions, 'bottom')) {\n                            cursor = 'row-resize';\n                            this.setSubIsOnEdge(true);\n                        } else if (includes(directions, 'right') && includes(directions, 'left')) {\n                            cursor = 'col-resize';\n                            this.setSubIsOnEdge(true);\n                        } else {\n                            cursor = 'default';\n                            this.setSubIsOnEdge(false);\n                        }\n                        container.css('cursor', cursor);\n                    } else {\n                        if (!this.subIsOnEdge) {\n                            container.css('cursor', 'default');\n                            this.setSubIsOnEdge(false);\n                        }\n                    }\n                }\n\n            },\n            onMouseLeave(e) {\n                if (!this.options.allowResize && !this.editMode)\n                    return;\n                this.onMouseUp();\n                this.setSubIsOnEdge(false);\n            },\n            onDrag(e) {\n\n                let perc = this._getPrecPoint(e);\n\n                let xDiff = perc.x - this.dragStartPt.x;\n                let yDiff = perc.y - this.dragStartPt.y;\n\n                let okToDrag = true;\n\n                for (let i in this.closestLines) {\n                    let line = this.closestLines[i];\n                    let origLine = this.dragStartLines[i];\n                    let top = parseFloat(origLine.cssRules.top);\n                    let bottom = parseFloat(origLine.cssRules.bottom);\n                    let left = parseFloat(origLine.cssRules.left);\n                    let right = parseFloat(origLine.cssRules.right);\n                    let originalHeight = this._getLayoutByWidget(line.widget).percentHeight;\n                    let originalWidth = this._getLayoutByWidget(line.widget).percentWidth;\n                    if (line.cssRelevantRule === 'top') {\n                        let newTop = top + yDiff;\n                        let newHeight = 100 - bottom - newTop;\n                        if (newHeight < 0.2 * originalHeight) {\n                            okToDrag = false;\n                            break;\n                        }\n                    } else if (line.cssRelevantRule === 'bottom') {\n                        let newBottom = bottom - yDiff;\n                        let newHeight = 100 - newBottom - top;\n                        if (newHeight < 0.2 * originalHeight) {\n                            okToDrag = false;\n                            break;\n                        }\n                    } else if (line.cssRelevantRule === 'left') {\n                        let newLeft = left + xDiff;\n                        let newWidth = 100 - right - newLeft;\n                        if (newWidth < 0.2 * originalWidth) {\n                            okToDrag = false;\n                            break;\n                        }\n                    } else if (line.cssRelevantRule === 'right') {\n                        let newRight = right - xDiff;\n                        let newWidth = 100 - newRight - left;\n                        if (newWidth < 0.2 * originalWidth) {\n                            okToDrag = false;\n                            break;\n                        }\n                    }\n                }\n\n                if (okToDrag) {\n                    for (let i in this.closestLines) {\n                        let line = this.closestLines[i];\n\n                        if (!this.ensureCSSRulesSync(line, e))\n                            break;\n\n                        let origLine = this.dragStartLines[i];\n                        if (line.cssRelevantRule === 'top') {\n                            let top = parseFloat(origLine.cssRules.top);\n                            line.cssRules.top = top + yDiff + '%';\n                        } else if (line.cssRelevantRule === 'bottom') {\n                            let bottom = parseFloat(origLine.cssRules.bottom);\n                            line.cssRules.bottom = bottom - yDiff + '%';\n                        } else if (line.cssRelevantRule === 'left') {\n                            let left = parseFloat(origLine.cssRules.left);\n                            line.cssRules.left = left + xDiff + '%';\n                        } else if (line.cssRelevantRule === 'right') {\n                            let right = parseFloat(origLine.cssRules.right);\n                            line.cssRules.right = right - xDiff + '%';\n                        }\n                    }\n                }\n\n            },\n            ensureCSSRulesSync(line, e) {\n\n                // Very hacky solution TODO: Find a better solution!\n\n                let found = false;\n                for (let key in this.cssRules) {\n                    if (this.cssRules[key] === line.cssRules) {\n                        found = true;\n                        break;\n                    }\n                }\n\n                if (!found) {\n                    this.onMouseUp();\n                    this.onMouseMove(e);\n                    this.onMouseDown(e);\n                    this.onMouseMove(e);\n                    return false;\n                }\n                return true;\n            },\n            onMouseDown(e) {\n\n                if (!this.options.allowResize && !this.editMode)\n                    return;\n\n                if (this.closestLines && this.closestLines.length) {\n                    this.draggingLines = true;\n                    this.dragStartPt = cloneDeep(this._getPrecPoint(e));\n                    this.dragStartLines = cloneDeep(this.closestLines);\n                    this._setTransitions(false);\n                    e.preventDefault();\n                    e.stopPropagation();\n                }\n            },\n            onMouseUp(e) {\n                if (!this.options.allowResize && !this.editMode)\n                    return;\n\n                this.updateDragLines();\n                this.closestLines = null;\n                this.draggingLines = false;\n                this.dragStartPt = null;\n                this.dragStartLines = null;\n\n                if (e)\n                    this._setTransitions(true);\n\n            },\n            onWidgetMouseMove(e) {\n                if (!this.options.allowResize && !this.editMode)\n                    return;\n                if (this.draggingLines || this.isParentDragging())\n                    return;\n                let container = $(this.$element).find('.jf-widgets-layout-container');\n                if (!this.subIsOnEdge) {\n                    container.css('cursor', 'default');\n                    this.setSubIsOnEdge(false);\n                }\n                e.stopPropagation();\n            },\n            addLinesFromRect(rect) {\n                this.dragLines.push({\n                    x1: rect.x1,\n                    y1: rect.y1,\n                    x2: rect.x2,\n                    y2: rect.y1,\n                    cssRules: rect.cssRules,\n                    widget: rect.widget,\n                    cssRelevantRule: 'top'\n                });\n                this.dragLines.push({\n                    x1: rect.x2,\n                    y1: rect.y1,\n                    x2: rect.x2,\n                    y2: rect.y2,\n                    cssRules: rect.cssRules,\n                    widget: rect.widget,\n                    cssRelevantRule: 'right'\n                });\n                this.dragLines.push({\n                    x1: rect.x1,\n                    y1: rect.y2,\n                    x2: rect.x2,\n                    y2: rect.y2,\n                    cssRules: rect.cssRules,\n                    widget: rect.widget,\n                    cssRelevantRule: 'bottom'\n                });\n                this.dragLines.push({\n                    x1: rect.x1,\n                    y1: rect.y1,\n                    x2: rect.x1,\n                    y2: rect.y2,\n                    cssRules: rect.cssRules,\n                    widget: rect.widget,\n                    cssRelevantRule: 'left'\n                });\n            },\n            getClosestLines(x, y) {\n                let closest = [];\n\n                this.dragLines.forEach(line => {\n\n                    let infinite = (line.cssRelevantRule === 'bottom' || line.cssRelevantRule === 'top') && this.mainAxis === 'rows' || (line.cssRelevantRule === 'right' || line.cssRelevantRule === 'left') && this.mainAxis === 'columns';\n                    let dist = this.getPointDistToLine({\n                        x: x,\n                        y: y\n                    }, line, infinite);\n                    if (dist <= 1)\n                        closest.push(line);\n                });\n\n                let filtered = [];\n\n                let top = filter(closest, { cssRelevantRule: 'top' });\n                let bottom = filter(closest, { cssRelevantRule: 'bottom' });\n                let left = filter(closest, { cssRelevantRule: 'left' });\n                let right = filter(closest, { cssRelevantRule: 'right' });\n\n                top.forEach(line => {\n                    let matches = this.mainAxis === 'rows' ? filter(bottom, { y1: line.y1 }) : filter(bottom, {\n                        x1: line.x1,\n                        x2: line.x2\n                    });\n\n                    if (matches.length) {\n                        filtered.push(line);\n                        matches.forEach(match => filtered.push(match));\n                    }\n                });\n                left.forEach(line => {\n                    let matches = this.mainAxis === 'columns' ? filter(right, { x1: line.x1 }) : filter(right, {\n                        y1: line.y1,\n                        y2: line.y2\n                    });\n\n                    if (matches.length) {\n                        filtered.push(line);\n                        matches.forEach(match => filtered.push(match));\n                    }\n                });\n\n                return filtered;\n            },\n            getPointDistToLine(pt, line, infiniteLine) {\n                if (line.x1 === line.x2) {\n                    if (infiniteLine)\n                        return Math.abs(pt.x - line.x1);\n                    else if (pt.y < line.y1)\n                        return this.getPointDistToPoint(pt, {\n                            x: line.x1,\n                            y: line.y1\n                        });\n                    else if (pt.y > line.y2)\n                        return this.getPointDistToPoint(pt, {\n                            x: line.x2,\n                            y: line.y2\n                        });\n                    else\n                        return Math.abs(pt.x - line.x1);\n                } else if (line.y1 === line.y2) {\n                    if (infiniteLine)\n                        return Math.abs(pt.y - line.y1);\n                    if (pt.x < line.x1)\n                        return this.getPointDistToPoint(pt, {\n                            x: line.x1,\n                            y: line.y1\n                        });\n                    else if (pt.x > line.x2)\n                        return this.getPointDistToPoint(pt, {\n                            x: line.x2,\n                            y: line.y2\n                        });\n                    else\n                        return Math.abs(pt.y - line.y1);\n                }\n            },\n            getPointDistToPoint(pt1, pt2) {\n                return Math.sqrt(Math.pow(pt1.x - pt2.x, 2) + Math.pow(pt1.y - pt2.y, 2));\n            },\n            setSubIsOnEdge(onEdge) {\n                let parent = this.options.parent;\n                while (parent) {\n                    parent.subIsOnEdge = onEdge;\n                    parent = parent.options.parent;\n                }\n            },\n            isParentDragging(recurse = false) {\n                let parent = this.options.parent;\n                if (parent)\n                    return parent.draggingLines || parent.isParentDragging(true);\n                else\n                    return recurse ? this.draggingLines : false;\n            },\n            removeWidget(layoutObj) {\n                this._setTransitions(true);\n\n                let rowOrColumnToRemove = null;\n                this.transformedLayout.forEach(rowOrColumn => {\n                    let index = indexOf(rowOrColumn, layoutObj);\n                    if (index !== -1) {\n                        rowOrColumn.splice(index, 1);\n                        if (rowOrColumn.length === 0) {\n                            rowOrColumnToRemove = rowOrColumn;\n                        }\n                    }\n                });\n                if (rowOrColumnToRemove) {\n                    let index = indexOf(this.transformedLayout, rowOrColumnToRemove);\n                    this.transformedLayout.splice(index, 1);\n                }\n                if (this.transformedLayout.length === 0) {\n                    if (this.options.isSub) {\n                        let parentLayoutObj = find(this.options.parent.flatCells, { subLayout: this.layout });\n                        this.options.parent.removeWidget(parentLayoutObj);\n                    }\n                }\n                this.megaRefresh();\n            },\n            normalizeSizes() {\n                let totalSizeMajor = 0;\n                this.transformedLayout.forEach(rowOrColumn => {\n                    let totalSizeMinor = 0;\n                    let totalSizeMajorAdd = 0;\n                    rowOrColumn.forEach(cell => {\n                        totalSizeMinor += this.mainAxis === 'columns' ? cell.percentHeight : cell.percentWidth;\n                        let major = this.mainAxis === 'columns' ? cell.percentWidth : cell.percentHeight;\n                        totalSizeMajorAdd = major > totalSizeMajorAdd ? major : totalSizeMajorAdd;\n                    });\n                    totalSizeMajor += totalSizeMajorAdd;\n                    if (totalSizeMinor !== 100) {\n                        rowOrColumn.forEach(cell => {\n                            if (this.mainAxis === 'columns') {\n                                cell.percentHeight = 100 * cell.percentHeight / totalSizeMinor;\n                            } else {\n                                cell.percentWidth = 100 * cell.percentWidth / totalSizeMinor;\n                            }\n                        });\n                    }\n                });\n                if (totalSizeMajor !== 100) {\n                    this.transformedLayout.forEach(rowOrColumn => {\n                        rowOrColumn.forEach(cell => {\n                            if (this.mainAxis === 'columns') {\n                                cell.percentWidth = 100 * cell.percentWidth / totalSizeMajor;\n                            } else {\n                                cell.percentHeight = 100 * cell.percentHeight / totalSizeMajor;\n                            }\n                        });\n                    });\n                }\n            },\n            splitCell(layoutObj, orientation) {\n                this._setTransitions(true);\n                this.transformedLayout.forEach(rowOrColumn => {\n                    let index = indexOf(rowOrColumn, layoutObj);\n                    if (index !== -1) {\n                        let clone = angular.copy(layoutObj);\n                        if (orientation === 'h' && this.mainAxis === 'rows' || orientation === 'v' && this.mainAxis === 'columns') {\n                            let attr = orientation === 'h' ? 'percentWidth' : 'percentHeight';\n                            layoutObj[attr] /= 2;\n                            clone[attr] /= 2;\n                            rowOrColumn.splice(index + 1, 0, clone);\n                            clone.selectWidgetMode = true;\n                        } else {\n                            delete layoutObj.widget;\n                            layoutObj.subLayout = {};\n                            let axis = this.mainAxis === 'columns' ? 'rows' : 'columns';\n                            layoutObj.subLayout[axis] = [{\n                                    size: '100%',\n                                    cells: ['100% @' + clone.widget],\n                                    new: true\n                                }];\n                        }\n                    }\n                });\n\n                this.megaRefresh();\n            },\n            megaRefresh() {\n                this.updateFlatCells();\n                this.normalizeSizes();\n                this.updateCss();\n                this.updateDragLines();\n                this.loadTemplates().then(() => {\n                    this.$timeout(() => this.compileElements());\n                });\n            },\n            changeWidget(layoutObj) {\n                layoutObj.selectWidgetMode = !layoutObj.selectWidgetMode;\n                this.updateCss();\n            },\n            onWidgetChange(layoutObj) {\n                layoutObj.selectWidgetMode = false;\n                this.templatesLoaded = false;\n                this.megaRefresh();\n            },\n            getWidgetName(key) {\n                return this.widgets[key] ? this.widgets[key].name || key : '';\n            },\n            updateLayoutJSON() {\n                if (!this.transformedLayout)\n                    return;\n\n                this.layoutJSON = {};\n                this.layoutJSON.main = {};\n                this.layoutJSON.main[this.mainAxis] = [];\n                let subLayoutCounter = 0;\n\n                this.transformedLayout.forEach(rowOrColumn => {\n                    let rowOrColumnObject = {};\n                    rowOrColumn.forEach(cell => {\n                        if (!rowOrColumnObject.size)\n                            rowOrColumnObject.size = cell[this.mainAxis === 'columns' ? 'percentWidth' : 'percentHeight'] + '%';\n                        if (!rowOrColumnObject.cells)\n                            rowOrColumnObject.cells = [];\n\n                        let cellString = '';\n                        cellString += cell[this.mainAxis === 'columns' ? 'percentHeight' : 'percentWidth'] + '%';\n                        if (cell.widget && !cell.widget.startsWith('$'))\n                            cellString += ' @' + cell.widget;\n\n                        if (cell.$childLayout) {\n                            cell.$childLayout.updateLayoutJSON();\n\n                            let subName = 'sub' + subLayoutCounter;\n                            subLayoutCounter++;\n\n                            this.layoutJSON[subName] = cell.$childLayout.layoutJSON;\n                            cellString += ' #' + subName;\n                        }\n\n                        rowOrColumnObject.cells.push(cellString);\n                    });\n\n                    this.layoutJSON.main[this.mainAxis].push(rowOrColumnObject);\n                });\n\n            },\n            getWidgetsCount() {\n                return $('.widget-container').length;\n            },\n            _setTransitions(active) {\n                if (active) {\n                    $('.widgets-padder .widget-wrapper').css('transition', `all ${ this.ANIM_DURATION }s ease-out`);\n                } else {\n                    $('.widgets-padder .widget-wrapper').css('transition', 'none');\n                }\n            },\n            _getRootDirective() {\n                if (!this.options.parent)\n                    return this;\n                else\n                    return this.options.parent._getRootDirective();\n            },\n            cleanLayout() {\n                if (!this.transformedLayout)\n                    return;\n\n                // Remove empty layout directives from parent\n                if (!this.transformedLayout.length && this.options.parent) {\n                    let parentLayoutObj = find(this.options.parent.flatCells, { subLayout: this.layout });\n                    this.options.parent.removeWidget(parentLayoutObj);\n                }\n\n                     // In case this directive is a sub and only has one widget in one cell, we move the widget to parent\n                else if (this.transformedLayout.length === 1 && this.transformedLayout[0].length === 1 && this.transformedLayout[0][0].percentHeight === 100 && this.transformedLayout[0][0].percentWidth === 100 && this.options.parent) {\n\n                    let parentLayoutObj = find(this.options.parent.flatCells, { subLayout: this.layout });\n                    let axis = Object.keys(parentLayoutObj.subLayout)[0];\n                    if (!parentLayoutObj.subLayout[axis][0] || parentLayoutObj.subLayout[axis][0] && !parentLayoutObj.subLayout[axis][0].new) {\n                        if (this.transformedLayout[0][0].widget) {\n                            parentLayoutObj.widget = this.transformedLayout[0][0].widget;\n                            delete parentLayoutObj.subLayout;\n                            delete parentLayoutObj.$childLayout;\n                        } else if (this.transformedLayout[0][0].subLayout) {\n                            parentLayoutObj.subLayout = this.transformedLayout[0][0].subLayout;\n                            delete parentLayoutObj.widget;\n                        }\n                    }\n                }\n\n                     // In case this directive is the root and only has one sub in one cell, we move the sub data to this\n                else if (this.transformedLayout.length === 1 && this.transformedLayout[0].length === 1 && this.transformedLayout[0][0].percentHeight === 100 && this.transformedLayout[0][0].percentWidth === 100 && this.transformedLayout[0][0].subLayout && !this.options.parent) {\n\n                    console.log('pre', JSON.stringify(this.layout));\n                    let theSub = this.transformedLayout[0][0].subLayout;\n                    this.layout = theSub;\n                    console.log('post', JSON.stringify(this.layout));\n                    this.transformLayout();\n                    this.cleanLayout();\n\n                }\n\n            },\n            expandPane(layoutObj) {\n                let expanding = this.$expanded = !this.$expanded ? layoutObj : null;\n                this.transformedLayout.forEach(rowOrColumn => {\n                    rowOrColumn.forEach(cell => {\n                        if (expanding) {\n                            cell.dimBeforeExpansion = {\n                                width: cell.percentWidth,\n                                height: cell.percentHeight\n                            };\n                            if (cell === layoutObj) {\n                                cell.percentWidth = cell.percentHeight = 100;\n                            } else {\n                                this.cssRules[cell.cssId].opacity = 0;\n                                let onTheSameRowOrColumn = rowOrColumn.indexOf(layoutObj) !== -1;\n                                if (onTheSameRowOrColumn) {\n                                    cell[this.mainAxis === 'columns' ? 'percentHeight' : 'percentWidth'] = 0;\n                                    cell[this.mainAxis === 'rows' ? 'percentHeight' : 'percentWidth'] = 100;\n                                } else {\n                                    cell[this.mainAxis === 'rows' ? 'percentHeight' : 'percentWidth'] = 0;\n                                    cell[this.mainAxis === 'columns' ? 'percentHeight' : 'percentWidth'] = 100;\n                                }\n                            }\n                        } else {\n                            cell.percentWidth = cell.dimBeforeExpansion.width;\n                            cell.percentHeight = cell.dimBeforeExpansion.height;\n                            delete cell.dimBeforeExpansion;\n                        }\n                    });\n                });\n\n                if (expanding) {\n                    this.$timeout(() => {\n                        this.updateCss();\n                    }, this.ANIM_DURATION * 1000);\n                } else {\n                    this.updateCss();\n                    this.$timeout(() => {\n                        this.transformedLayout.forEach(rowOrColumn => {\n                            rowOrColumn.forEach(cell => {\n                                this.cssRules[cell.cssId].opacity = 1;\n                            });\n                        })\n    ;\n                    }, this.ANIM_DURATION * 1000);\n                }\n\n                if (this.options.parent && this.parentCell) {\n                    this.options.parent.expandPane(this.parentCell);\n                }\n\n                layoutObj.expanded = !layoutObj.expanded;\n\n            }\n\n        }\n    };\n\n</script>\n\n<style scoped lang=\"less\">\n\n\n\n</style>\n","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=script&lang=js&\"","var render, staticRenderFns\nimport script from \"./index.vue?vue&type=script&lang=js&\"\nexport * from \"./index.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"1e79feea\",\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}