{"version":3,"sources":["webpack://jfrog-ui-essentials/./node_modules/jf-tooltipster/css/tooltipster.css?45e2","webpack://jfrog-ui-essentials/./node_modules/jf-tooltipster/js/jquery.tooltipster.js"],"names":[],"mappings":";;;;;AAAA,uC;;;;;;;ACAA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,IAAI;AACJ,8CAA8C;AAC9C,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;;AAEA;AACA;;AAEA;AACA,iDAAiD,kBAAkB,EAAE;AACrE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iFAAiF,wDAAwD,sDAAsD,qDAAqD,oDAAoD,mDAAmD,qDAAqD,oDAAoD,iDAAiD,gDAAgD;AACriB,+FAA+F;AAC/F,+FAA+F;AAC/F,wEAAwE;;AAExE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,UAAU;AACV;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,kBAAkB,EAAE;AACnE;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kEAAkE;AAClE;AACA,8EAA8E;AAC9E;AACA;AACA,iFAAiF;AACjF;AACA;AACA,gFAAgF;AAChF;AACA;AACA,+EAA+E;AAC/E;AACA,gHAAgH;AAChH;;AAEA;AACA;;AAEA;AACA,qKAAqK;AACrK;AACA;;AAEA;AACA,uBAAuB,mEAAmE;AAC1F;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,kFAAkF;AAClF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,YAAY;;AAE3C;AACA;AACA,cAAc,YAAY;AAC1B,uCAAuC,aAAa;AACpD;AACA;AACA;AACA,CAAC","file":"jfrog-ui-essentials.umd.vendors~JfTooltipDirective~JfTooltipOnOverflowDirective.js","sourcesContent":["// extracted by mini-css-extract-plugin","/*\r\n\r\nTooltipster 3.3.0 | 2014-11-08\r\nA rockin' custom tooltip jQuery plugin\r\n\r\nDeveloped by Caleb Jacob under the MIT license http://opensource.org/licenses/MIT\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n*/\r\n\r\n;(function ($, window, document) {\r\n\r\n\tvar pluginName = \"tooltipster\",\r\n\t\tdefaults = {\r\n\t\t\tanimation: 'fade',\r\n\t\t\tarrow: true,\r\n\t\t\tarrowColor: '',\r\n\t\t\tautoClose: true,\n\t\t\tcontent: null,\r\n\t\t\tcontentAsHTML: false,\r\n\t\t\tcontentCloning: true,\r\n\t\t\tdebug: true,\r\n\t\t\tdelay: 200,\r\n\t\t\tminWidth: 0,\r\n\t\t\tmaxWidth: null,\r\n\t\t\tfunctionInit: function(origin, content) {},\r\n\t\t\tfunctionBefore: function(origin, continueTooltip) {\r\n\t\t\t\tcontinueTooltip();\r\n\t\t\t},\r\n\t\t\tfunctionReady: function(origin, tooltip) {},\r\n\t\t\tfunctionAfter: function(origin) {},\r\n\t\t\thideOnClick: false,\r\n\t\t\ticon: '(?)',\r\n\t\t\ticonCloning: true,\r\n\t\t\ticonDesktop: false,\r\n\t\t\ticonTouch: false,\r\n\t\t\ticonTheme: 'tooltipster-icon',\r\n\t\t\tinteractive: false,\r\n\t\t\tinteractiveTolerance: 350,\r\n\t\t\tmultiple: false,\r\n\t\t\toffsetX: 0,\r\n\t\t\toffsetY: 0,\r\n\t\t\tonlyOne: false,\r\n\t\t\tposition: 'top',\r\n\t\t\tpositionTracker: false,\n\t\t\tpositionTrackerCallback: function(origin){\n\t\t\t\t// the default tracker callback will close the tooltip when the trigger is\n\t\t\t\t// 'hover' (see https://github.com/iamceege/tooltipster/pull/253)\n\t\t\t\tif(this.option('trigger') == 'hover' && this.option('autoClose')) {\n\t\t\t\t\tthis.hide();\n\t\t\t\t}\n\t\t\t},\r\n\t\t\trestoration: 'current',\r\n\t\t\tspeed: 350,\r\n\t\t\ttimer: 0,\r\n\t\t\ttheme: 'tooltipster-default',\r\n\t\t\ttouchDevices: true,\r\n\t\t\ttrigger: 'hover',\r\n\t\t\tupdateAnimation: true\r\n\t\t};\r\n\t\r\n\tfunction Plugin(element, options) {\r\n\t\t\r\n\t\t// list of instance variables\r\n\t\t\r\n\t\tthis.bodyOverflowX;\r\n\t\t// stack of custom callbacks provided as parameters to API methods\r\n\t\tthis.callbacks = {\r\n\t\t\thide: [],\r\n\t\t\tshow: []\r\n\t\t};\r\n\t\tthis.checkInterval = null;\r\n\t\t// this will be the user content shown in the tooltip. A capital \"C\" is used because there is also a method called content()\r\n\t\tthis.Content;\r\n\t\t// this is the original element which is being applied the tooltipster plugin\r\n\t\tthis.$el = $(element);\r\n\t\t// this will be the element which triggers the appearance of the tooltip on hover/click/custom events.\r\n\t\t// it will be the same as this.$el if icons are not used (see in the options), otherwise it will correspond to the created icon\r\n\t\tthis.$elProxy;\r\n\t\tthis.elProxyPosition;\r\n\t\tthis.enabled = true;\r\n\t\tthis.options = $.extend({}, defaults, options);\r\n\t\tthis.mouseIsOverProxy = false;\r\n\t\t// a unique namespace per instance, for easy selective unbinding\r\n\t\tthis.namespace = 'tooltipster-'+ Math.round(Math.random()*100000);\r\n\t\t// Status (capital S) can be either : appearing, shown, disappearing, hidden\r\n\t\tthis.Status = 'hidden';\r\n\t\tthis.timerHide = null;\r\n\t\tthis.timerShow = null;\r\n\t\t// this will be the tooltip element (jQuery wrapped HTML element)\r\n\t\tthis.$tooltip;\r\n\t\t\r\n\t\t// for backward compatibility\r\n\t\tthis.options.iconTheme = this.options.iconTheme.replace('.', '');\r\n\t\tthis.options.theme = this.options.theme.replace('.', '');\r\n\t\t\r\n\t\t// launch\r\n\t\t\r\n\t\tthis._init();\r\n\t}\r\n\t\r\n\tPlugin.prototype = {\r\n\t\t\r\n\t\t_init: function() {\r\n\t\t\t\r\n\t\t\tvar self = this;\r\n\t\t\t\r\n\t\t\t// disable the plugin on old browsers (including IE7 and lower)\r\n\t\t\tif (document.querySelector) {\r\n\t\t\t\t\r\n\t\t\t\t// note : the content is null (empty) by default and can stay that way if the plugin remains initialized but not fed any content. The tooltip will just not appear.\r\n\t\t\t\t\r\n\t\t\t\t// let's save the initial value of the title attribute for later restoration if need be.\r\n\t\t\t\tvar initialTitle = null;\r\n\t\t\t\t// it will already have been saved in case of multiple tooltips\r\n\t\t\t\tif (self.$el.data('tooltipster-initialTitle') === undefined) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tinitialTitle = self.$el.attr('title');\r\n\t\t\t\t\t\r\n\t\t\t\t\t// we do not want initialTitle to have the value \"undefined\" because of how jQuery's .data() method works\r\n\t\t\t\t\tif (initialTitle === undefined) initialTitle = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tself.$el.data('tooltipster-initialTitle', initialTitle);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// if content is provided in the options, its has precedence over the title attribute.\r\n\t\t\t\t// Note : an empty string is considered content, only 'null' represents the absence of content.\r\n\t\t\t\t// Also, an existing title=\"\" attribute will result in an empty string content\r\n\t\t\t\tif (self.options.content !== null){\r\n\t\t\t\t\tself._content_set(self.options.content);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tself._content_set(initialTitle);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar c = self.options.functionInit.call(self.$el, self.$el, self.Content);\r\n\t\t\t\tif(typeof c !== 'undefined') self._content_set(c);\r\n\t\t\t\t\r\n\t\t\t\tself.$el\r\n\t\t\t\t\t// strip the title off of the element to prevent the default tooltips from popping up\r\n\t\t\t\t\t.removeAttr('title')\r\n\t\t\t\t\t// to be able to find all instances on the page later (upon window events in particular)\r\n\t\t\t\t\t.addClass('tooltipstered');\r\n\r\n\t\t\t\t// detect if we're changing the tooltip origin to an icon\r\n\t\t\t\t// note about this condition : if the device has touch capability and self.options.iconTouch is false, you'll have no icons event though you may consider your device as a desktop if it also has a mouse. Not sure why someone would have this use case though.\r\n\t\t\t\tif ((!deviceHasTouchCapability && self.options.iconDesktop) || (deviceHasTouchCapability && self.options.iconTouch)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// TODO : the tooltip should be automatically be given an absolute position to be near the origin. Otherwise, when the origin is floating or what, it's going to be nowhere near it and disturb the position flow of the page elements. It will imply that the icon also detects when its origin moves, to follow it : not trivial.\r\n\t\t\t\t\t// Until it's done, the icon feature does not really make sense since the user still has most of the work to do by himself\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the icon provided is in the form of a string\r\n\t\t\t\t\tif(typeof self.options.icon === 'string'){\r\n\t\t\t\t\t\t// wrap it in a span with the icon class\r\n\t\t\t\t\t\tself.$elProxy = $('<span class=\"'+ self.options.iconTheme +'\"></span>');\r\n\t\t\t\t\t\tself.$elProxy.text(self.options.icon);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if it is an object (sensible choice)\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// (deep) clone the object if iconCloning == true, to make sure every instance has its own proxy. We use the icon without wrapping, no need to. We do not give it a class either, as the user will undoubtedly style the object on his own and since our css properties may conflict with his own\r\n\t\t\t\t\t\tif (self.options.iconCloning) self.$elProxy = self.options.icon.clone(true);\r\n\t\t\t\t\t\telse self.$elProxy = self.options.icon;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tself.$elProxy.insertAfter(self.$el);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tself.$elProxy = self.$el;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// for 'click' and 'hover' triggers : bind on events to open the tooltip. Closing is now handled in _showNow() because of its bindings.\r\n\t\t\t\t// Notes about touch events :\r\n\t\t\t\t\t// - mouseenter, mouseleave and clicks happen even on pure touch devices because they are emulated. deviceIsPureTouch() is a simple attempt to detect them.\r\n\t\t\t\t\t// - on hybrid devices, we do not prevent touch gesture from opening tooltips. It would be too complex to differentiate real mouse events from emulated ones.\r\n\t\t\t\t\t// - we check deviceIsPureTouch() at each event rather than prior to binding because the situation may change during browsing\r\n\t\t\t\tif (self.options.trigger == 'hover') {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// these binding are for mouse interaction only\r\n\t\t\t\t\tself.$elProxy\r\n\t\t\t\t\t\t.on('mouseenter.'+ self.namespace, function() {\r\n\t\t\t\t\t\t\tif (!deviceIsPureTouch() || self.options.touchDevices) {\r\n\t\t\t\t\t\t\t\tself.mouseIsOverProxy = true;\r\n\t\t\t\t\t\t\t\tself._show();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.on('mouseleave.'+ self.namespace, function() {\r\n\t\t\t\t\t\t\tif (!deviceIsPureTouch() || self.options.touchDevices) {\r\n\t\t\t\t\t\t\t\tself.mouseIsOverProxy = false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\r\n\t\t\t\t\t// for touch interaction only\r\n\t\t\t\t\tif (deviceHasTouchCapability && self.options.touchDevices) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// for touch devices, we immediately display the tooltip because we cannot rely on mouseleave to handle the delay\r\n\t\t\t\t\t\tself.$elProxy.on('touchstart.'+ self.namespace, function() {\r\n\t\t\t\t\t\t\tself._showNow();\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (self.options.trigger == 'click') {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// note : for touch devices, we do not bind on touchstart, we only rely on the emulated clicks (triggered by taps)\r\n\t\t\t\t\tself.$elProxy.on('click.'+ self.namespace, function() {\r\n\t\t\t\t\t\tif (!deviceIsPureTouch() || self.options.touchDevices) {\r\n\t\t\t\t\t\t\tself._show();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t// this function will schedule the opening of the tooltip after the delay, if there is one\r\n\t\t_show: function() {\r\n\t\t\t\r\n\t\t\tvar self = this;\r\n\t\t\t\r\n\t\t\tif (self.Status != 'shown' && self.Status != 'appearing') {\r\n\t\t\t\t\r\n\t\t\t\tif (self.options.delay) {\r\n\t\t\t\t\tself.timerShow = setTimeout(function(){\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// for hover trigger, we check if the mouse is still over the proxy, otherwise we do not show anything\r\n\t\t\t\t\t\tif (self.options.trigger == 'click' || (self.options.trigger == 'hover' && self.mouseIsOverProxy)) {\r\n\t\t\t\t\t\t\tself._showNow();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, self.options.delay);\r\n\t\t\t\t}\r\n\t\t\t\telse self._showNow();\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t// this function will open the tooltip right away\r\n\t\t_showNow: function(callback) {\r\n\t\t\t\r\n\t\t\tvar self = this;\r\n\t\t\t\r\n\t\t\t// call our constructor custom function before continuing\r\n\t\t\tself.options.functionBefore.call(self.$el, self.$el, function() {\r\n\t\t\t\t\r\n\t\t\t\t// continue only if the tooltip is enabled and has any content\r\n\t\t\t\tif (self.enabled && self.Content !== null) {\r\n\t\t\t\t\r\n\t\t\t\t\t// save the method callback and cancel hide method callbacks\r\n\t\t\t\t\tif (callback) self.callbacks.show.push(callback);\r\n\t\t\t\t\tself.callbacks.hide = [];\r\n\t\t\t\t\t\r\n\t\t\t\t\t//get rid of any appearance timer\r\n\t\t\t\t\tclearTimeout(self.timerShow);\r\n\t\t\t\t\tself.timerShow = null;\r\n\t\t\t\t\tclearTimeout(self.timerHide);\r\n\t\t\t\t\tself.timerHide = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if we only want one tooltip open at a time, close all auto-closing tooltips currently open and not already disappearing\r\n\t\t\t\t\tif (self.options.onlyOne) {\r\n\t\t\t\t\t\t$('.tooltipstered').not(self.$el).each(function(i,el) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tvar $el = $(el),\r\n\t\t\t\t\t\t\t\tnss = $el.data('tooltipster-ns');\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// iterate on all tooltips of the element\r\n\t\t\t\t\t\t\t$.each(nss, function(i, ns){\r\n\t\t\t\t\t\t\t\tvar instance = $el.data(ns),\r\n\t\t\t\t\t\t\t\t\t// we have to use the public methods here\r\n\t\t\t\t\t\t\t\t\ts = instance.status(),\r\n\t\t\t\t\t\t\t\t\tac = instance.option('autoClose');\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif (s !== 'hidden' && s !== 'disappearing' && ac) {\r\n\t\t\t\t\t\t\t\t\tinstance.hide();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar finish = function() {\r\n\t\t\t\t\t\tself.Status = 'shown';\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// trigger any show method custom callbacks and reset them\r\n\t\t\t\t\t\t$.each(self.callbacks.show, function(i,c) { c.call(self.$el); });\r\n\t\t\t\t\t\tself.callbacks.show = [];\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if this origin already has its tooltip open\r\n\t\t\t\t\tif (self.Status !== 'hidden') {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// the timer (if any) will start (or restart) right now\r\n\t\t\t\t\t\tvar extraTime = 0;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// if it was disappearing, cancel that\r\n\t\t\t\t\t\tif (self.Status === 'disappearing') {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tself.Status = 'appearing';\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (supportsTransitions()) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tself.$tooltip\r\n\t\t\t\t\t\t\t\t\t.clearQueue()\r\n\t\t\t\t\t\t\t\t\t.removeClass('tooltipster-dying')\r\n\t\t\t\t\t\t\t\t\t.addClass('tooltipster-'+ self.options.animation +'-show');\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif (self.options.speed > 0) self.$tooltip.delay(self.options.speed);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tself.$tooltip.queue(finish);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t// in case the tooltip was currently fading out, bring it back to life\r\n\t\t\t\t\t\t\t\tself.$tooltip\r\n\t\t\t\t\t\t\t\t\t.stop()\r\n\t\t\t\t\t\t\t\t\t.fadeIn(finish);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if the tooltip is already open, we still need to trigger the method custom callback\r\n\t\t\t\t\t\telse if(self.Status === 'shown') {\r\n\t\t\t\t\t\t\tfinish();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if the tooltip isn't already open, open that sucker up!\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tself.Status = 'appearing';\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// the timer (if any) will start when the tooltip has fully appeared after its transition\r\n\t\t\t\t\t\tvar extraTime = self.options.speed;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// disable horizontal scrollbar to keep overflowing tooltips from jacking with it and then restore it to its previous value\r\n\t\t\t\t\t\tself.bodyOverflowX = $('body').css('overflow-x');\r\n\t\t\t\t\t\t$('body').css('overflow-x', 'hidden');\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// get some other settings related to building the tooltip\r\n\t\t\t\t\t\tvar animation = 'tooltipster-' + self.options.animation,\r\n\t\t\t\t\t\t\tanimationSpeed = '-webkit-transition-duration: '+ self.options.speed +'ms; -webkit-animation-duration: '+ self.options.speed +'ms; -moz-transition-duration: '+ self.options.speed +'ms; -moz-animation-duration: '+ self.options.speed +'ms; -o-transition-duration: '+ self.options.speed +'ms; -o-animation-duration: '+ self.options.speed +'ms; -ms-transition-duration: '+ self.options.speed +'ms; -ms-animation-duration: '+ self.options.speed +'ms; transition-duration: '+ self.options.speed +'ms; animation-duration: '+ self.options.speed +'ms;',\r\n\t\t\t\t\t\t\tminWidth = self.options.minWidth ? 'min-width:'+ Math.round(self.options.minWidth) +'px;' : '',\r\n\t\t\t\t\t\t\tmaxWidth = self.options.maxWidth ? 'max-width:'+ Math.round(self.options.maxWidth) +'px;' : '',\r\n\t\t\t\t\t\t\tpointerEvents = self.options.interactive ? 'pointer-events: auto;' : '';\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// build the base of our tooltip\r\n\t\t\t\t\t\tself.$tooltip = $('<div class=\"tooltipster-base '+ self.options.theme +'\" style=\"'+ minWidth +' '+ maxWidth +' '+ pointerEvents +' '+ animationSpeed +'\"><div class=\"tooltipster-content\"></div></div>');\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// only add the animation class if the user has a browser that supports animations\r\n\t\t\t\t\t\tif (supportsTransitions()) self.$tooltip.addClass(animation);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// insert the content\r\n\t\t\t\t\t\tself._content_insert();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// attach\r\n\t\t\t\t\t\tself.$tooltip.appendTo('body');\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// do all the crazy calculations and positioning\r\n\t\t\t\t\t\tself.reposition();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// call our custom callback since the content of the tooltip is now part of the DOM\r\n\t\t\t\t\t\tself.options.functionReady.call(self.$el, self.$el, self.$tooltip);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// animate in the tooltip\r\n\t\t\t\t\t\tif (supportsTransitions()) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tself.$tooltip.addClass(animation + '-show');\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(self.options.speed > 0) self.$tooltip.delay(self.options.speed);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tself.$tooltip.queue(finish);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tself.$tooltip.css('display', 'none').fadeIn(self.options.speed, finish);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// will check if our tooltip origin is removed while the tooltip is shown\r\n\t\t\t\t\t\tself._interval_set();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// reposition on scroll (otherwise position:fixed element's tooltips will move away form their origin) and on resize (in case position can/has to be changed)\r\n\t\t\t\t\t\t$(window).on('scroll.'+ self.namespace +' resize.'+ self.namespace, function() {\r\n\t\t\t\t\t\t\tself.reposition();\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// auto-close bindings\r\n\t\t\t\t\t\tif (self.options.autoClose) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// in case a listener is already bound for autoclosing (mouse or touch, hover or click), unbind it first\r\n\t\t\t\t\t\t\t$('body').off('.'+ self.namespace);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// here we'll have to set different sets of bindings for both touch and mouse\r\n\t\t\t\t\t\t\tif (self.options.trigger == 'hover') {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// if the user touches the body, hide\r\n\t\t\t\t\t\t\t\tif (deviceHasTouchCapability) {\r\n\t\t\t\t\t\t\t\t\t// timeout 0 : explanation below in click section\r\n\t\t\t\t\t\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\t\t\t\t\t\t// we don't want to bind on click here because the initial touchstart event has not yet triggered its click event, which is thus about to happen\r\n\t\t\t\t\t\t\t\t\t\t$('body').on('touchstart.'+ self.namespace, function() {\r\n\t\t\t\t\t\t\t\t\t\t\tself.hide();\r\n\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// if we have to allow interaction\r\n\t\t\t\t\t\t\t\tif (self.options.interactive) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// touch events inside the tooltip must not close it\r\n\t\t\t\t\t\t\t\t\tif (deviceHasTouchCapability) {\r\n\t\t\t\t\t\t\t\t\t\tself.$tooltip.on('touchstart.'+ self.namespace, function(event) {\r\n\t\t\t\t\t\t\t\t\t\t\tevent.stopPropagation();\r\n\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// as for mouse interaction, we get rid of the tooltip only after the mouse has spent some time out of it\r\n\t\t\t\t\t\t\t\t\tvar tolerance = null;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tself.$elProxy.add(self.$tooltip)\r\n\t\t\t\t\t\t\t\t\t\t// hide after some time out of the proxy and the tooltip\r\n\t\t\t\t\t\t\t\t\t\t.on('mouseleave.'+ self.namespace + '-autoClose', function() {\r\n\t\t\t\t\t\t\t\t\t\t\tclearTimeout(tolerance);\r\n\t\t\t\t\t\t\t\t\t\t\ttolerance = setTimeout(function(){\r\n\t\t\t\t\t\t\t\t\t\t\t\tself.hide();\r\n\t\t\t\t\t\t\t\t\t\t\t}, self.options.interactiveTolerance);\r\n\t\t\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t\t\t// suspend timeout when the mouse is over the proxy or the tooltip\r\n\t\t\t\t\t\t\t\t\t\t.on('mouseenter.'+ self.namespace + '-autoClose', function() {\r\n\t\t\t\t\t\t\t\t\t\t\tclearTimeout(tolerance);\r\n\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// if this is a non-interactive tooltip, get rid of it if the mouse leaves\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tself.$elProxy.on('mouseleave.'+ self.namespace + '-autoClose', function() {\r\n\t\t\t\t\t\t\t\t\t\tself.hide();\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// close the tooltip when the proxy gets a click (common behavior of native tooltips)\n\t\t\t\t\t\t\t\tif (self.options.hideOnClick) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tself.$elProxy.on('click.'+ self.namespace + '-autoClose', function() {\n\t\t\t\t\t\t\t\t\t\tself.hide();\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// here we'll set the same bindings for both clicks and touch on the body to hide the tooltip\r\n\t\t\t\t\t\t\telse if(self.options.trigger == 'click'){\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// use a timeout to prevent immediate closing if the method was called on a click event and if options.delay == 0 (because of bubbling)\r\n\t\t\t\t\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\t\t\t\t\t$('body').on('click.'+ self.namespace +' touchstart.'+ self.namespace, function() {\r\n\t\t\t\t\t\t\t\t\t\tself.hide();\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// if interactive, we'll stop the events that were emitted from inside the tooltip to stop autoClosing\r\n\t\t\t\t\t\t\t\tif (self.options.interactive) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// note : the touch events will just not be used if the plugin is not enabled on touch devices\r\n\t\t\t\t\t\t\t\t\tself.$tooltip.on('click.'+ self.namespace +' touchstart.'+ self.namespace, function(event) {\r\n\t\t\t\t\t\t\t\t\t\tevent.stopPropagation();\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if we have a timer set, let the countdown begin\r\n\t\t\t\t\tif (self.options.timer > 0) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tself.timerHide = setTimeout(function() {\r\n\t\t\t\t\t\t\tself.timerHide = null;\r\n\t\t\t\t\t\t\tself.hide();\r\n\t\t\t\t\t\t}, self.options.timer + extraTime);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t_interval_set: function() {\r\n\t\t\t\r\n\t\t\tvar self = this;\r\n\t\t\t\r\n\t\t\tself.checkInterval = setInterval(function() {\r\n\t\t\t\t\r\n\t\t\t\t// if the tooltip and/or its interval should be stopped\r\n\t\t\t\tif (\r\n\t\t\t\t\t\t// if the origin has been removed\r\n\t\t\t\t\t\t$('body').find(self.$el).length === 0\r\n\t\t\t\t\t\t// if the elProxy has been removed\r\n\t\t\t\t\t||\t$('body').find(self.$elProxy).length === 0\r\n\t\t\t\t\t\t// if the tooltip has been closed\r\n\t\t\t\t\t||\tself.Status == 'hidden'\r\n\t\t\t\t\t\t// if the tooltip has somehow been removed\r\n\t\t\t\t\t||\t$('body').find(self.$tooltip).length === 0\r\n\t\t\t\t) {\r\n\t\t\t\t\t// remove the tooltip if it's still here\r\n\t\t\t\t\tif (self.Status == 'shown' || self.Status == 'appearing') self.hide();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// clear this interval as it is no longer necessary\r\n\t\t\t\t\tself._interval_cancel();\r\n\t\t\t\t}\r\n\t\t\t\t// if everything is alright\r\n\t\t\t\telse {\r\n\t\t\t\t\t// compare the former and current positions of the elProxy to reposition the tooltip if need be\r\n\t\t\t\t\tif(self.options.positionTracker){\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar p = self._repositionInfo(self.$elProxy),\r\n\t\t\t\t\t\t\tidentical = false;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// compare size first (a change requires repositioning too)\r\n\t\t\t\t\t\tif(areEqual(p.dimension, self.elProxyPosition.dimension)){\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// for elements with a fixed position, we track the top and left properties (relative to window)\r\n\t\t\t\t\t\t\tif(self.$elProxy.css('position') === 'fixed'){\r\n\t\t\t\t\t\t\t\tif(areEqual(p.position, self.elProxyPosition.position)) identical = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// otherwise, track total offset (relative to document)\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tif(areEqual(p.offset, self.elProxyPosition.offset)) identical = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(!identical){\r\n\t\t\t\t\t\t\tself.reposition();\n\t\t\t\t\t\t\tself.options.positionTrackerCallback.call(self, self.$el);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, 200);\r\n\t\t},\r\n\t\t\r\n\t\t_interval_cancel: function() {\r\n\t\t\tclearInterval(this.checkInterval);\r\n\t\t\t// clean delete\r\n\t\t\tthis.checkInterval = null;\r\n\t\t},\r\n\t\t\r\n\t\t_content_set: function(content) {\r\n\t\t\t// clone if asked. Cloning the object makes sure that each instance has its own version of the content (in case a same object were provided for several instances)\r\n\t\t\t// reminder : typeof null === object\r\n\t\t\tif (typeof content === 'object' && content !== null && this.options.contentCloning) {\r\n\t\t\t\tcontent = content.clone(true);\r\n\t\t\t}\r\n\t\t\tthis.Content = content;\r\n\t\t},\r\n\t\t\r\n\t\t_content_insert: function() {\r\n\t\t\t\r\n\t\t\tvar self = this,\r\n\t\t\t\t$d = this.$tooltip.find('.tooltipster-content');\r\n\t\t\t\r\n\t\t\tif (typeof self.Content === 'string' && !self.options.contentAsHTML) {\r\n\t\t\t\t$d.text(self.Content);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t$d\r\n\t\t\t\t\t.empty()\r\n\t\t\t\t\t.append(self.Content);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t_update: function(content) {\r\n\t\t\t\r\n\t\t\tvar self = this;\r\n\t\t\t\r\n\t\t\t// change the content\r\n\t\t\tself._content_set(content);\r\n\t\t\t\r\n\t\t\tif (self.Content !== null) {\r\n\t\t\t\t\r\n\t\t\t\t// update the tooltip if it is open\r\n\t\t\t\tif (self.Status !== 'hidden') {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// reset the content in the tooltip\r\n\t\t\t\t\tself._content_insert();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// reposition and resize the tooltip\r\n\t\t\t\t\tself.reposition();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if we want to play a little animation showing the content changed\r\n\t\t\t\t\tif (self.options.updateAnimation) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (supportsTransitions()) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tself.$tooltip.css({\r\n\t\t\t\t\t\t\t\t'width': '',\r\n\t\t\t\t\t\t\t\t'-webkit-transition': 'all ' + self.options.speed + 'ms, width 0ms, height 0ms, left 0ms, top 0ms',\r\n\t\t\t\t\t\t\t\t'-moz-transition': 'all ' + self.options.speed + 'ms, width 0ms, height 0ms, left 0ms, top 0ms',\r\n\t\t\t\t\t\t\t\t'-o-transition': 'all ' + self.options.speed + 'ms, width 0ms, height 0ms, left 0ms, top 0ms',\r\n\t\t\t\t\t\t\t\t'-ms-transition': 'all ' + self.options.speed + 'ms, width 0ms, height 0ms, left 0ms, top 0ms',\r\n\t\t\t\t\t\t\t\t'transition': 'all ' + self.options.speed + 'ms, width 0ms, height 0ms, left 0ms, top 0ms'\r\n\t\t\t\t\t\t\t}).addClass('tooltipster-content-changing');\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// reset the CSS transitions and finish the change animation\r\n\t\t\t\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif(self.Status != 'hidden'){\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tself.$tooltip.removeClass('tooltipster-content-changing');\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// after the changing animation has completed, reset the CSS transitions\r\n\t\t\t\t\t\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\tif(self.Status !== 'hidden'){\r\n\t\t\t\t\t\t\t\t\t\t\tself.$tooltip.css({\r\n\t\t\t\t\t\t\t\t\t\t\t\t'-webkit-transition': self.options.speed + 'ms',\r\n\t\t\t\t\t\t\t\t\t\t\t\t'-moz-transition': self.options.speed + 'ms',\r\n\t\t\t\t\t\t\t\t\t\t\t\t'-o-transition': self.options.speed + 'ms',\r\n\t\t\t\t\t\t\t\t\t\t\t\t'-ms-transition': self.options.speed + 'ms',\r\n\t\t\t\t\t\t\t\t\t\t\t\t'transition': self.options.speed + 'ms'\r\n\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}, self.options.speed);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}, self.options.speed);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tself.$tooltip.fadeTo(self.options.speed, 0.5, function() {\r\n\t\t\t\t\t\t\t\tif(self.Status != 'hidden'){\r\n\t\t\t\t\t\t\t\t\tself.$tooltip.fadeTo(self.options.speed, 1);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tself.hide();\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t_repositionInfo: function($el) {\r\n\t\t\treturn {\r\n\t\t\t\tdimension: {\r\n\t\t\t\t\theight: $el.outerHeight(false),\r\n\t\t\t\t\twidth: $el.outerWidth(false)\r\n\t\t\t\t},\r\n\t\t\t\toffset: $el.offset(),\r\n\t\t\t\tposition: {\r\n\t\t\t\t\tleft: parseInt($el.css('left')),\r\n\t\t\t\t\ttop: parseInt($el.css('top'))\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\thide: function(callback) {\r\n\t\t\t\r\n\t\t\tvar self = this;\r\n\t\t\t\r\n\t\t\t// save the method custom callback and cancel any show method custom callbacks\r\n\t\t\tif (callback) self.callbacks.hide.push(callback);\r\n\t\t\tself.callbacks.show = [];\r\n\t\t\t\r\n\t\t\t// get rid of any appearance timeout\r\n\t\t\tclearTimeout(self.timerShow);\r\n\t\t\tself.timerShow = null;\r\n\t\t\tclearTimeout(self.timerHide);\r\n\t\t\tself.timerHide = null;\r\n\t\t\t\r\n\t\t\tvar finishCallbacks = function() {\r\n\t\t\t\t// trigger any hide method custom callbacks and reset them\r\n\t\t\t\t$.each(self.callbacks.hide, function(i,c) { c.call(self.$el); });\r\n\t\t\t\tself.callbacks.hide = [];\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\t// hide\r\n\t\t\tif (self.Status == 'shown' || self.Status == 'appearing') {\r\n\t\t\t\t\r\n\t\t\t\tself.Status = 'disappearing';\r\n\t\t\t\t\r\n\t\t\t\tvar finish = function() {\r\n\t\t\t\t\t\r\n\t\t\t\t\tself.Status = 'hidden';\r\n\t\t\t\t\t\r\n\t\t\t\t\t// detach our content object first, so the next jQuery's remove() call does not unbind its event handlers\r\n\t\t\t\t\tif (typeof self.Content == 'object' && self.Content !== null) {\r\n\t\t\t\t\t\tself.Content.detach();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tself.$tooltip.remove();\r\n\t\t\t\t\tself.$tooltip = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// unbind orientationchange, scroll and resize listeners\r\n\t\t\t\t\t$(window).off('.'+ self.namespace);\r\n\t\t\t\t\t\r\n\t\t\t\t\t$('body')\r\n\t\t\t\t\t\t// unbind any auto-closing click/touch listeners\r\n\t\t\t\t\t\t.off('.'+ self.namespace)\r\n\t\t\t\t\t\t.css('overflow-x', self.bodyOverflowX);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// unbind any auto-closing click/touch listeners\r\n\t\t\t\t\t$('body').off('.'+ self.namespace);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// unbind any auto-closing hover listeners\r\n\t\t\t\t\tself.$elProxy.off('.'+ self.namespace + '-autoClose');\r\n\t\t\t\t\t\r\n\t\t\t\t\t// call our constructor custom callback function\r\n\t\t\t\t\tself.options.functionAfter.call(self.$el, self.$el);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// call our method custom callbacks functions\r\n\t\t\t\t\tfinishCallbacks();\r\n\t\t\t\t};\r\n\t\t\t\t\r\n\t\t\t\tif (supportsTransitions()) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tself.$tooltip\r\n\t\t\t\t\t\t.clearQueue()\r\n\t\t\t\t\t\t.removeClass('tooltipster-' + self.options.animation + '-show')\r\n\t\t\t\t\t\t// for transitions only\r\n\t\t\t\t\t\t.addClass('tooltipster-dying');\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(self.options.speed > 0) self.$tooltip.delay(self.options.speed);\r\n\t\t\t\t\t\r\n\t\t\t\t\tself.$tooltip.queue(finish);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tself.$tooltip\r\n\t\t\t\t\t\t.stop()\r\n\t\t\t\t\t\t.fadeOut(self.options.speed, finish);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// if the tooltip is already hidden, we still need to trigger the method custom callback\r\n\t\t\telse if(self.Status == 'hidden') {\r\n\t\t\t\tfinishCallbacks();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn self;\r\n\t\t},\r\n\t\t\r\n\t\t// the public show() method is actually an alias for the private showNow() method\r\n\t\tshow: function(callback) {\r\n\t\t\tthis._showNow(callback);\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t\r\n\t\t// 'update' is deprecated in favor of 'content' but is kept for backward compatibility\r\n\t\tupdate: function(c) {\r\n\t\t\treturn this.content(c);\r\n\t\t},\r\n\t\tcontent: function(c) {\r\n\t\t\t// getter method\r\n\t\t\tif(typeof c === 'undefined'){\r\n\t\t\t\treturn this.Content;\r\n\t\t\t}\r\n\t\t\t// setter method\r\n\t\t\telse {\r\n\t\t\t\tthis._update(c);\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\treposition: function() {\r\n\t\t\t\r\n\t\t\tvar self = this;\r\n\t\t\t\r\n\t\t\t// in case the tooltip has been removed from DOM manually\r\n\t\t\tif ($('body').find(self.$tooltip).length !== 0) {\r\n\t\t\t\t\r\n\t\t\t\t// reset width\r\n\t\t\t\tself.$tooltip.css('width', '');\r\n\t\t\t\t\r\n\t\t\t\t// find variables to determine placement\r\n\t\t\t\tself.elProxyPosition = self._repositionInfo(self.$elProxy);\r\n\t\t\t\tvar arrowReposition = null,\r\n\t\t\t\t\twindowWidth = $(window).width(),\r\n\t\t\t\t\t// shorthand\r\n\t\t\t\t\tproxy = self.elProxyPosition,\r\n\t\t\t\t\ttooltipWidth = self.$tooltip.outerWidth(false),\r\n\t\t\t\t\ttooltipInnerWidth = self.$tooltip.innerWidth() + 1, // this +1 stops FireFox from sometimes forcing an additional text line\r\n\t\t\t\t\ttooltipHeight = self.$tooltip.outerHeight(false);\r\n\t\t\t\t\r\n\t\t\t\t// if this is an <area> tag inside a <map>, all hell breaks loose. Recalculate all the measurements based on coordinates\r\n\t\t\t\tif (self.$elProxy.is('area')) {\r\n\t\t\t\t\tvar areaShape = self.$elProxy.attr('shape'),\r\n\t\t\t\t\t\tmapName = self.$elProxy.parent().attr('name'),\r\n\t\t\t\t\t\tmap = $('img[usemap=\"#'+ mapName +'\"]'),\r\n\t\t\t\t\t\tmapOffsetLeft = map.offset().left,\r\n\t\t\t\t\t\tmapOffsetTop = map.offset().top,\r\n\t\t\t\t\t\tareaMeasurements = self.$elProxy.attr('coords') !== undefined ? self.$elProxy.attr('coords').split(',') : undefined;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (areaShape == 'circle') {\r\n\t\t\t\t\t\tvar areaLeft = parseInt(areaMeasurements[0]),\r\n\t\t\t\t\t\t\tareaTop = parseInt(areaMeasurements[1]),\r\n\t\t\t\t\t\t\tareaWidth = parseInt(areaMeasurements[2]);\r\n\t\t\t\t\t\tproxy.dimension.height = areaWidth * 2;\r\n\t\t\t\t\t\tproxy.dimension.width = areaWidth * 2;\r\n\t\t\t\t\t\tproxy.offset.top = mapOffsetTop + areaTop - areaWidth;\r\n\t\t\t\t\t\tproxy.offset.left = mapOffsetLeft + areaLeft - areaWidth;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (areaShape == 'rect') {\r\n\t\t\t\t\t\tvar areaLeft = parseInt(areaMeasurements[0]),\r\n\t\t\t\t\t\t\tareaTop = parseInt(areaMeasurements[1]),\r\n\t\t\t\t\t\t\tareaRight = parseInt(areaMeasurements[2]),\r\n\t\t\t\t\t\t\tareaBottom = parseInt(areaMeasurements[3]);\r\n\t\t\t\t\t\tproxy.dimension.height = areaBottom - areaTop;\r\n\t\t\t\t\t\tproxy.dimension.width = areaRight - areaLeft;\r\n\t\t\t\t\t\tproxy.offset.top = mapOffsetTop + areaTop;\r\n\t\t\t\t\t\tproxy.offset.left = mapOffsetLeft + areaLeft;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (areaShape == 'poly') {\r\n\t\t\t\t\t\tvar areaXs = [],\r\n\t\t\t\t\t\t\tareaYs = [],\r\n\t\t\t\t\t\t\tareaSmallestX = 0,\r\n\t\t\t\t\t\t\tareaSmallestY = 0,\r\n\t\t\t\t\t\t\tareaGreatestX = 0,\r\n\t\t\t\t\t\t\tareaGreatestY = 0,\r\n\t\t\t\t\t\t\tarrayAlternate = 'even';\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfor (var i = 0; i < areaMeasurements.length; i++) {\r\n\t\t\t\t\t\t\tvar areaNumber = parseInt(areaMeasurements[i]);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (arrayAlternate == 'even') {\r\n\t\t\t\t\t\t\t\tif (areaNumber > areaGreatestX) {\r\n\t\t\t\t\t\t\t\t\tareaGreatestX = areaNumber;\r\n\t\t\t\t\t\t\t\t\tif (i === 0) {\r\n\t\t\t\t\t\t\t\t\t\tareaSmallestX = areaGreatestX;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif (areaNumber < areaSmallestX) {\r\n\t\t\t\t\t\t\t\t\tareaSmallestX = areaNumber;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tarrayAlternate = 'odd';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tif (areaNumber > areaGreatestY) {\r\n\t\t\t\t\t\t\t\t\tareaGreatestY = areaNumber;\r\n\t\t\t\t\t\t\t\t\tif (i == 1) {\r\n\t\t\t\t\t\t\t\t\t\tareaSmallestY = areaGreatestY;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif (areaNumber < areaSmallestY) {\r\n\t\t\t\t\t\t\t\t\tareaSmallestY = areaNumber;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tarrayAlternate = 'even';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tproxy.dimension.height = areaGreatestY - areaSmallestY;\r\n\t\t\t\t\t\tproxy.dimension.width = areaGreatestX - areaSmallestX;\r\n\t\t\t\t\t\tproxy.offset.top = mapOffsetTop + areaSmallestY;\r\n\t\t\t\t\t\tproxy.offset.left = mapOffsetLeft + areaSmallestX;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tproxy.dimension.height = map.outerHeight(false);\r\n\t\t\t\t\t\tproxy.dimension.width = map.outerWidth(false);\r\n\t\t\t\t\t\tproxy.offset.top = mapOffsetTop;\r\n\t\t\t\t\t\tproxy.offset.left = mapOffsetLeft;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// our function and global vars for positioning our tooltip\r\n\t\t\t\tvar myLeft = 0,\r\n\t\t\t\t\tmyLeftMirror = 0,\r\n\t\t\t\t\tmyTop = 0,\r\n\t\t\t\t\toffsetY = parseInt(self.options.offsetY),\r\n\t\t\t\t\toffsetX = parseInt(self.options.offsetX),\r\n\t\t\t\t\t// this is the arrow position that will eventually be used. It may differ from the position option if the tooltip cannot be displayed in this position\r\n\t\t\t\t\tpracticalPosition = self.options.position;\r\n\t\t\t\t\r\n\t\t\t\t// a function to detect if the tooltip is going off the screen horizontally. If so, reposition the crap out of it!\r\n\t\t\t\tfunction dontGoOffScreenX() {\r\n\t\t\t\t\r\n\t\t\t\t\tvar windowLeft = $(window).scrollLeft();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the tooltip goes off the left side of the screen, line it up with the left side of the window\r\n\t\t\t\t\tif((myLeft - windowLeft) < 0) {\r\n\t\t\t\t\t\tarrowReposition = myLeft - windowLeft;\r\n\t\t\t\t\t\tmyLeft = windowLeft;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the tooltip goes off the right of the screen, line it up with the right side of the window\r\n\t\t\t\t\tif (((myLeft + tooltipWidth) - windowLeft) > windowWidth) {\r\n\t\t\t\t\t\tarrowReposition = myLeft - ((windowWidth + windowLeft) - tooltipWidth);\r\n\t\t\t\t\t\tmyLeft = (windowWidth + windowLeft) - tooltipWidth;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// a function to detect if the tooltip is going off the screen vertically. If so, switch to the opposite!\r\n\t\t\t\tfunction dontGoOffScreenY(switchTo, switchFrom) {\r\n\t\t\t\t\t// if it goes off the top off the page\r\n\t\t\t\t\tif(((proxy.offset.top - $(window).scrollTop() - tooltipHeight - offsetY - 12) < 0) && (switchFrom.indexOf('top') > -1)) {\r\n\t\t\t\t\t\tpracticalPosition = switchTo;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if it goes off the bottom of the page\r\n\t\t\t\t\tif (((proxy.offset.top + proxy.dimension.height + tooltipHeight + 12 + offsetY) > ($(window).scrollTop() + $(window).height())) && (switchFrom.indexOf('bottom') > -1)) {\r\n\t\t\t\t\t\tpracticalPosition = switchTo;\r\n\t\t\t\t\t\tmyTop = (proxy.offset.top - tooltipHeight) - offsetY - 12;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(practicalPosition == 'top') {\r\n\t\t\t\t\tvar leftDifference = (proxy.offset.left + tooltipWidth) - (proxy.offset.left + proxy.dimension.width);\r\n\t\t\t\t\tmyLeft = (proxy.offset.left + offsetX) - (leftDifference / 2);\r\n\t\t\t\t\tmyTop = (proxy.offset.top - tooltipHeight) - offsetY - 12;\r\n\t\t\t\t\tdontGoOffScreenX();\r\n\t\t\t\t\tdontGoOffScreenY('bottom', 'top');\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(practicalPosition == 'top-left') {\r\n\t\t\t\t\tmyLeft = proxy.offset.left + offsetX;\r\n\t\t\t\t\tmyTop = (proxy.offset.top - tooltipHeight) - offsetY - 12;\r\n\t\t\t\t\tdontGoOffScreenX();\r\n\t\t\t\t\tdontGoOffScreenY('bottom-left', 'top-left');\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(practicalPosition == 'top-right') {\r\n\t\t\t\t\tmyLeft = (proxy.offset.left + proxy.dimension.width + offsetX) - tooltipWidth;\r\n\t\t\t\t\tmyTop = (proxy.offset.top - tooltipHeight) - offsetY - 12;\r\n\t\t\t\t\tdontGoOffScreenX();\r\n\t\t\t\t\tdontGoOffScreenY('bottom-right', 'top-right');\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(practicalPosition == 'bottom') {\r\n\t\t\t\t\tvar leftDifference = (proxy.offset.left + tooltipWidth) - (proxy.offset.left + proxy.dimension.width);\r\n\t\t\t\t\tmyLeft = proxy.offset.left - (leftDifference / 2) + offsetX;\r\n\t\t\t\t\tmyTop = (proxy.offset.top + proxy.dimension.height) + offsetY + 12;\r\n\t\t\t\t\tdontGoOffScreenX();\r\n\t\t\t\t\tdontGoOffScreenY('top', 'bottom');\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(practicalPosition == 'bottom-left') {\r\n\t\t\t\t\tmyLeft = proxy.offset.left + offsetX;\r\n\t\t\t\t\tmyTop = (proxy.offset.top + proxy.dimension.height) + offsetY + 12;\r\n\t\t\t\t\tdontGoOffScreenX();\r\n\t\t\t\t\tdontGoOffScreenY('top-left', 'bottom-left');\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(practicalPosition == 'bottom-right') {\r\n\t\t\t\t\tmyLeft = (proxy.offset.left + proxy.dimension.width + offsetX) - tooltipWidth;\r\n\t\t\t\t\tmyTop = (proxy.offset.top + proxy.dimension.height) + offsetY + 12;\r\n\t\t\t\t\tdontGoOffScreenX();\r\n\t\t\t\t\tdontGoOffScreenY('top-right', 'bottom-right');\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(practicalPosition == 'left') {\r\n\t\t\t\t\tmyLeft = proxy.offset.left - offsetX - tooltipWidth - 12;\r\n\t\t\t\t\tmyLeftMirror = proxy.offset.left + offsetX + proxy.dimension.width + 12;\r\n\t\t\t\t\tvar topDifference = (proxy.offset.top + tooltipHeight) - (proxy.offset.top + proxy.dimension.height);\r\n\t\t\t\t\tmyTop = proxy.offset.top - (topDifference / 2) - offsetY;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the tooltip goes off boths sides of the page\r\n\t\t\t\t\tif((myLeft < 0) && ((myLeftMirror + tooltipWidth) > windowWidth)) {\r\n\t\t\t\t\t\tvar borderWidth = parseFloat(self.$tooltip.css('border-width')) * 2,\r\n\t\t\t\t\t\t\tnewWidth = (tooltipWidth + myLeft) - borderWidth;\r\n\t\t\t\t\t\tself.$tooltip.css('width', newWidth + 'px');\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\ttooltipHeight = self.$tooltip.outerHeight(false);\r\n\t\t\t\t\t\tmyLeft = proxy.offset.left - offsetX - newWidth - 12 - borderWidth;\r\n\t\t\t\t\t\ttopDifference = (proxy.offset.top + tooltipHeight) - (proxy.offset.top + proxy.dimension.height);\r\n\t\t\t\t\t\tmyTop = proxy.offset.top - (topDifference / 2) - offsetY;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if it only goes off one side, flip it to the other side\r\n\t\t\t\t\telse if(myLeft < 0) {\r\n\t\t\t\t\t\tmyLeft = proxy.offset.left + offsetX + proxy.dimension.width + 12;\r\n\t\t\t\t\t\tarrowReposition = 'left';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(practicalPosition == 'right') {\r\n\t\t\t\t\tmyLeft = proxy.offset.left + offsetX + proxy.dimension.width + 12;\r\n\t\t\t\t\tmyLeftMirror = proxy.offset.left - offsetX - tooltipWidth - 12;\r\n\t\t\t\t\tvar topDifference = (proxy.offset.top + tooltipHeight) - (proxy.offset.top + proxy.dimension.height);\r\n\t\t\t\t\tmyTop = proxy.offset.top - (topDifference / 2) - offsetY;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the tooltip goes off boths sides of the page\r\n\t\t\t\t\tif(((myLeft + tooltipWidth) > windowWidth) && (myLeftMirror < 0)) {\r\n\t\t\t\t\t\tvar borderWidth = parseFloat(self.$tooltip.css('border-width')) * 2,\r\n\t\t\t\t\t\t\tnewWidth = (windowWidth - myLeft) - borderWidth;\r\n\t\t\t\t\t\tself.$tooltip.css('width', newWidth + 'px');\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\ttooltipHeight = self.$tooltip.outerHeight(false);\r\n\t\t\t\t\t\ttopDifference = (proxy.offset.top + tooltipHeight) - (proxy.offset.top + proxy.dimension.height);\r\n\t\t\t\t\t\tmyTop = proxy.offset.top - (topDifference / 2) - offsetY;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t// if it only goes off one side, flip it to the other side\r\n\t\t\t\t\telse if((myLeft + tooltipWidth) > windowWidth) {\r\n\t\t\t\t\t\tmyLeft = proxy.offset.left - offsetX - tooltipWidth - 12;\r\n\t\t\t\t\t\tarrowReposition = 'right';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// if arrow is set true, style it and append it\r\n\t\t\t\tif (self.options.arrow) {\r\n\t\r\n\t\t\t\t\tvar arrowClass = 'tooltipster-arrow-' + practicalPosition;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// set color of the arrow\r\n\t\t\t\t\tif(self.options.arrowColor.length < 1) {\r\n\t\t\t\t\t\tvar arrowColor = self.$tooltip.css('background-color');\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar arrowColor = self.options.arrowColor;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the tooltip was going off the page and had to re-adjust, we need to update the arrow's position\r\n\t\t\t\t\tif (!arrowReposition) {\r\n\t\t\t\t\t\tarrowReposition = '';\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (arrowReposition == 'left') {\r\n\t\t\t\t\t\tarrowClass = 'tooltipster-arrow-right';\r\n\t\t\t\t\t\tarrowReposition = '';\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (arrowReposition == 'right') {\r\n\t\t\t\t\t\tarrowClass = 'tooltipster-arrow-left';\r\n\t\t\t\t\t\tarrowReposition = '';\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tarrowReposition = 'left:'+ Math.round(arrowReposition) +'px;';\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// building the logic to create the border around the arrow of the tooltip\r\n\t\t\t\t\tif ((practicalPosition == 'top') || (practicalPosition == 'top-left') || (practicalPosition == 'top-right')) {\r\n\t\t\t\t\t\tvar tooltipBorderWidth = parseFloat(self.$tooltip.css('border-bottom-width')),\r\n\t\t\t\t\t\t\ttooltipBorderColor = self.$tooltip.css('border-bottom-color');\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ((practicalPosition == 'bottom') || (practicalPosition == 'bottom-left') || (practicalPosition == 'bottom-right')) {\r\n\t\t\t\t\t\tvar tooltipBorderWidth = parseFloat(self.$tooltip.css('border-top-width')),\r\n\t\t\t\t\t\t\ttooltipBorderColor = self.$tooltip.css('border-top-color');\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (practicalPosition == 'left') {\r\n\t\t\t\t\t\tvar tooltipBorderWidth = parseFloat(self.$tooltip.css('border-right-width')),\r\n\t\t\t\t\t\t\ttooltipBorderColor = self.$tooltip.css('border-right-color');\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (practicalPosition == 'right') {\r\n\t\t\t\t\t\tvar tooltipBorderWidth = parseFloat(self.$tooltip.css('border-left-width')),\r\n\t\t\t\t\t\t\ttooltipBorderColor = self.$tooltip.css('border-left-color');\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar tooltipBorderWidth = parseFloat(self.$tooltip.css('border-bottom-width')),\r\n\t\t\t\t\t\t\ttooltipBorderColor = self.$tooltip.css('border-bottom-color');\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (tooltipBorderWidth > 1) {\r\n\t\t\t\t\t\ttooltipBorderWidth++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar arrowBorder = '';\r\n\t\t\t\t\tif (tooltipBorderWidth !== 0) {\r\n\t\t\t\t\t\tvar arrowBorderSize = '',\r\n\t\t\t\t\t\t\tarrowBorderColor = 'border-color: '+ tooltipBorderColor +';';\r\n\t\t\t\t\t\tif (arrowClass.indexOf('bottom') !== -1) {\r\n\t\t\t\t\t\t\tarrowBorderSize = 'margin-top: -'+ Math.round(tooltipBorderWidth) +'px;';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (arrowClass.indexOf('top') !== -1) {\r\n\t\t\t\t\t\t\tarrowBorderSize = 'margin-bottom: -'+ Math.round(tooltipBorderWidth) +'px;';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (arrowClass.indexOf('left') !== -1) {\r\n\t\t\t\t\t\t\tarrowBorderSize = 'margin-right: -'+ Math.round(tooltipBorderWidth) +'px;';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (arrowClass.indexOf('right') !== -1) {\r\n\t\t\t\t\t\t\tarrowBorderSize = 'margin-left: -'+ Math.round(tooltipBorderWidth) +'px;';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tarrowBorder = '<span class=\"tooltipster-arrow-border\" style=\"'+ arrowBorderSize +' '+ arrowBorderColor +';\"></span>';\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the arrow already exists, remove and replace it\r\n\t\t\t\t\tself.$tooltip.find('.tooltipster-arrow').remove();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// build out the arrow and append it\t\t\r\n\t\t\t\t\tvar arrowConstruct = '<div class=\"'+ arrowClass +' tooltipster-arrow\" style=\"'+ arrowReposition +'\">'+ arrowBorder +'<span style=\"border-color:'+ arrowColor +';\"></span></div>';\r\n\t\t\t\t\tself.$tooltip.append(arrowConstruct);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// position the tooltip\r\n\t\t\t\tself.$tooltip.css({'top': Math.round(myTop) + 'px', 'left': Math.round(myLeft) + 'px'});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn self;\r\n\t\t},\r\n\t\t\r\n\t\tenable: function() {\r\n\t\t\tthis.enabled = true;\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t\r\n\t\tdisable: function() {\r\n\t\t\t// hide first, in case the tooltip would not disappear on its own (autoClose false)\r\n\t\t\tthis.hide();\r\n\t\t\tthis.enabled = false;\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t\r\n\t\tdestroy: function() {\r\n\t\t\t\r\n\t\t\tvar self = this;\r\n\t\t\t\r\n\t\t\tself.hide();\r\n\t\t\t\r\n\t\t\t// remove the icon, if any\r\n\t\t\tif (self.$el[0] !== self.$elProxy[0]) {\r\n\t\t\t\tself.$elProxy.remove();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tself.$el\r\n\t\t\t\t.removeData(self.namespace)\r\n\t\t\t\t.off('.'+ self.namespace);\r\n\t\t\t\r\n\t\t\tvar ns = self.$el.data('tooltipster-ns');\r\n\t\t\t\r\n\t\t\t// if there are no more tooltips on this element\r\n\t\t\tif(ns.length === 1){\r\n\t\t\t\t\r\n\t\t\t\t// optional restoration of a title attribute\r\n\t\t\t\tvar title = null;\r\n\t\t\t\tif (self.options.restoration === 'previous'){\r\n\t\t\t\t\ttitle = self.$el.data('tooltipster-initialTitle');\r\n\t\t\t\t}\r\n\t\t\t\telse if(self.options.restoration === 'current'){\r\n\t\t\t\t\t\r\n\t\t\t\t\t// old school technique to stringify when outerHTML is not supported\r\n\t\t\t\t\ttitle =\r\n\t\t\t\t\t\t(typeof self.Content === 'string') ?\r\n\t\t\t\t\t\tself.Content :\r\n\t\t\t\t\t\t$('<div></div>').append(self.Content).html();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (title) {\r\n\t\t\t\t\tself.$el.attr('title', title);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// final cleaning\r\n\t\t\t\tself.$el\r\n\t\t\t\t\t.removeClass('tooltipstered')\r\n\t\t\t\t\t.removeData('tooltipster-ns')\r\n\t\t\t\t\t.removeData('tooltipster-initialTitle');\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// remove the instance namespace from the list of namespaces of tooltips present on the element\r\n\t\t\t\tns = $.grep(ns, function(el, i){\r\n\t\t\t\t\treturn el !== self.namespace;\r\n\t\t\t\t});\r\n\t\t\t\tself.$el.data('tooltipster-ns', ns);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn self;\r\n\t\t},\r\n\t\t\r\n\t\telementIcon: function() {\r\n\t\t\treturn (this.$el[0] !== this.$elProxy[0]) ? this.$elProxy[0] : undefined;\r\n\t\t},\r\n\t\t\r\n\t\telementTooltip: function() {\r\n\t\t\treturn this.$tooltip ? this.$tooltip[0] : undefined;\r\n\t\t},\r\n\t\t\r\n\t\t// public methods but for internal use only\n\t\t// getter if val is ommitted, setter otherwise\r\n\t\toption: function(o, val) {\n\t\t\tif (typeof val == 'undefined') return this.options[o];\r\n\t\t\telse {\n\t\t\t\tthis.options[o] = val;\n\t\t\t\treturn this;\n\t\t\t}\r\n\t\t},\r\n\t\tstatus: function() {\r\n\t\t\treturn this.Status;\r\n\t\t}\r\n\t};\r\n\t\r\n\t$.fn[pluginName] = function () {\r\n\t\t\r\n\t\t// for using in closures\r\n\t\tvar args = arguments;\r\n\t\t\r\n\t\t// if we are not in the context of jQuery wrapped HTML element(s) :\r\n\t\t// this happens when calling static methods in the form $.fn.tooltipster('methodName'), or when calling $(sel).tooltipster('methodName or options') where $(sel) does not match anything\r\n\t\tif (this.length === 0) {\r\n\t\t\t\r\n\t\t\t// if the first argument is a method name\r\n\t\t\tif (typeof args[0] === 'string') {\r\n\t\t\t\t\r\n\t\t\t\tvar methodIsStatic = true;\r\n\t\t\t\t\r\n\t\t\t\t// list static methods here (usable by calling $.fn.tooltipster('methodName');)\r\n\t\t\t\tswitch (args[0]) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tcase 'setDefaults':\r\n\t\t\t\t\t\t// change default options for all future instances\r\n\t\t\t\t\t\t$.extend(defaults, args[1]);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tmethodIsStatic = false;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// $.fn.tooltipster('methodName') calls will return true\r\n\t\t\t\tif (methodIsStatic) return true;\r\n\t\t\t\t// $(sel).tooltipster('methodName') calls will return the list of objects event though it's empty because chaining should work on empty lists\r\n\t\t\t\telse return this;\r\n\t\t\t}\r\n\t\t\t// the first argument is undefined or an object of options : we are initalizing but there is no element matched by selector\r\n\t\t\telse {\r\n\t\t\t\t// still chainable : same as above\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// this happens when calling $(sel).tooltipster('methodName or options') where $(sel) matches one or more elements\r\n\t\telse {\r\n\t\t\t\r\n\t\t\t// method calls\r\n\t\t\tif (typeof args[0] === 'string') {\r\n\t\t\t\t\r\n\t\t\t\tvar v = '#*$~&';\r\n\t\t\t\t\r\n\t\t\t\tthis.each(function() {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// retrieve the namepaces of the tooltip(s) that exist on that element. We will interact with the first tooltip only.\r\n\t\t\t\t\tvar ns = $(this).data('tooltipster-ns'),\r\n\t\t\t\t\t\t// self represents the instance of the first tooltipster plugin associated to the current HTML object of the loop\r\n\t\t\t\t\t\tself = ns ? $(this).data(ns[0]) : null;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if the current element holds a tooltipster instance\r\n\t\t\t\t\tif (self) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (typeof self[args[0]] === 'function') {\n\t\t\t\t\t\t\t// note : args[1] and args[2] may not be defined\r\n\t\t\t\t\t\t\tvar resp = self[args[0]](args[1], args[2]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tthrow new Error('Unknown method .tooltipster(\"' + args[0] + '\")');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// if the function returned anything other than the instance itself (which implies chaining)\r\n\t\t\t\t\t\tif (resp !== self){\r\n\t\t\t\t\t\t\tv = resp;\r\n\t\t\t\t\t\t\t// return false to stop .each iteration on the first element matched by the selector\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error('You called Tooltipster\\'s \"' + args[0] + '\" method on an uninitialized element');\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\treturn (v !== '#*$~&') ? v : this;\r\n\t\t\t}\r\n\t\t\t// first argument is undefined or an object : the tooltip is initializing\r\n\t\t\telse {\r\n\t\t\t\t\r\n\t\t\t\tvar instances = [],\r\n\t\t\t\t\t// is there a defined value for the multiple option in the options object ?\r\n\t\t\t\t\tmultipleIsSet = args[0] && typeof args[0].multiple !== 'undefined',\r\n\t\t\t\t\t// if the multiple option is set to true, or if it's not defined but set to true in the defaults\r\n\t\t\t\t\tmultiple = (multipleIsSet && args[0].multiple) || (!multipleIsSet && defaults.multiple),\r\n\t\t\t\t\t// same for debug\r\n\t\t\t\t\tdebugIsSet = args[0] && typeof args[0].debug !== 'undefined',\r\n\t\t\t\t\tdebug = (debugIsSet && args[0].debug) || (!debugIsSet && defaults.debug);\r\n\t\t\t\t\r\n\t\t\t\t// initialize a tooltipster instance for each element if it doesn't already have one or if the multiple option is set, and attach the object to it\r\n\t\t\t\tthis.each(function () {\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar go = false,\r\n\t\t\t\t\t\tns = $(this).data('tooltipster-ns'),\r\n\t\t\t\t\t\tinstance = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (!ns) {\r\n\t\t\t\t\t\tgo = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (multiple) {\r\n\t\t\t\t\t\tgo = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (debug) {\r\n\t\t\t\t\t\tconsole.log('Tooltipster: one or more tooltips are already attached to this element: ignoring. Use the \"multiple\" option to attach more tooltips.');\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (go) {\r\n\t\t\t\t\t\tinstance = new Plugin(this, args[0]);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// save the reference of the new instance\r\n\t\t\t\t\t\tif (!ns) ns = [];\r\n\t\t\t\t\t\tns.push(instance.namespace);\r\n\t\t\t\t\t\t$(this).data('tooltipster-ns', ns)\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// save the instance itself\r\n\t\t\t\t\t\t$(this).data(instance.namespace, instance);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tinstances.push(instance);\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tif (multiple) return instances;\r\n\t\t\t\telse return this;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t// quick & dirty compare function (not bijective nor multidimensional)\r\n\tfunction areEqual(a,b) {\r\n\t\tvar same = true;\r\n\t\t$.each(a, function(i, el){\r\n\t\t\tif(typeof b[i] === 'undefined' || a[i] !== b[i]){\r\n\t\t\t\tsame = false;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn same;\r\n\t}\r\n\t\r\n\t// detect if this device can trigger touch events\r\n\tvar deviceHasTouchCapability = !!('ontouchstart' in window);\r\n\t\r\n\t// we'll assume the device has no mouse until we detect any mouse movement\r\n\tvar deviceHasMouse = false;\r\n\t$('body').one('mousemove', function() {\r\n\t\tdeviceHasMouse = true;\r\n\t});\r\n\t\r\n\tfunction deviceIsPureTouch() {\r\n\t\treturn (!deviceHasMouse && deviceHasTouchCapability);\r\n\t}\r\n\t\r\n\t// detecting support for CSS transitions\r\n\tfunction supportsTransitions() {\r\n\t\tvar b = document.body || document.documentElement,\r\n\t\t\ts = b.style,\r\n\t\t\tp = 'transition';\r\n\t\t\r\n\t\tif(typeof s[p] == 'string') {return true; }\r\n\r\n\t\tv = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'],\r\n\t\tp = p.charAt(0).toUpperCase() + p.substr(1);\r\n\t\tfor(var i=0; i<v.length; i++) {\r\n\t\t\tif(typeof s[v[i] + p] == 'string') { return true; }\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n})( jQuery, window, document );\r\n"],"sourceRoot":""}