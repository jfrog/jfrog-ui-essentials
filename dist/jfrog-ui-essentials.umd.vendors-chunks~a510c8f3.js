((typeof self !== 'undefined' ? self : this)["webpackJsonpjfrog_ui_essentials"] = (typeof self !== 'undefined' ? self : this)["webpackJsonpjfrog_ui_essentials"] || []).push([[269],{

/***/ "5190":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_core_js_object_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a4bb");
/* harmony import */ var _Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_core_js_object_keys__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_core_js_object_keys__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_regexp_search__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("386d");
/* harmony import */ var core_js_modules_es6_regexp_search__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_search__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("75fc");
/* harmony import */ var _Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("bd86");
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("6b54");
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("06db");
/* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es6_number_constructor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("c5f6");
/* harmony import */ var core_js_modules_es6_number_constructor__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_number_constructor__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("f499");
/* harmony import */ var _Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("7618");
/* harmony import */ var _mixins_pointerScroll__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("13d5");
/* harmony import */ var _mixins_pointerScroll__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_mixins_pointerScroll__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _mixins_typeAheadPointer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("e08f");
/* harmony import */ var _mixins_typeAheadPointer__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_mixins_typeAheadPointer__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _mixins_ajax__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("ada1");
/* harmony import */ var _mixins_ajax__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_mixins_ajax__WEBPACK_IMPORTED_MODULE_11__);









//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ __webpack_exports__["a"] = ({
  mixins: [_mixins_pointerScroll__WEBPACK_IMPORTED_MODULE_9___default.a, _mixins_typeAheadPointer__WEBPACK_IMPORTED_MODULE_10___default.a, _mixins_ajax__WEBPACK_IMPORTED_MODULE_11___default.a],
  props: {
    /**
     * Contains the currently selected value. Very similar to a
     * `value` attribute on an <input>. You can listen for changes
     * using 'change' event using v-on
     * @type {Object||String||null}
     */
    value: {
      default: null
    },

    /**
     * An array of strings or objects to be used as dropdown choices.
     * If you are using an array of objects, vue-select will look for
     * a `label` key (ex. [{label: 'This is Foo', value: 'foo'}]). A
     * custom label key can be set with the `label` prop.
     * @type {Array}
     */
    options: {
      type: Array,
      default: function _default() {
        return [];
      }
    },

    /**
     * Disable the entire component.
     * @type {Boolean}
     */
    disabled: {
      type: Boolean,
      default: false
    },

    /**
     * Can the user clear the selected property.
     * @type {Boolean}
     */
    clearable: {
      type: Boolean,
      default: true
    },

    /**
     * Sets the max-height property on the dropdown list.
     * @deprecated
     * @type {String}
     */
    maxHeight: {
      type: String,
      default: '400px'
    },

    /**
     * Enable/disable filtering the options.
     * @type {Boolean}
     */
    searchable: {
      type: Boolean,
      default: true
    },

    /**
     * Equivalent to the `multiple` attribute on a `<select>` input.
     * @type {Boolean}
     */
    multiple: {
      type: Boolean,
      default: false
    },

    /**
     * Equivalent to the `placeholder` attribute on an `<input>`.
     * @type {String}
     */
    placeholder: {
      type: String,
      default: ''
    },

    /**
     * Sets a Vue transition property on the `.dropdown-menu`. vue-select
     * does not include CSS for transitions, you'll need to add them yourself.
     * @type {String}
     */
    transition: {
      type: String,
      default: 'fade'
    },

    /**
     * Enables/disables clearing the search text when an option is selected.
     * @type {Boolean}
     */
    clearSearchOnSelect: {
      type: Boolean,
      default: true
    },

    /**
     * Close a dropdown when an option is chosen. Set to false to keep the dropdown
     * open (useful when combined with multi-select, for example)
     * @type {Boolean}
     */
    closeOnSelect: {
      type: Boolean,
      default: true
    },

    /**
     * Tells vue-select what key to use when generating option
     * labels when each `option` is an object.
     * @type {String}
     */
    label: {
      type: String,
      default: 'label'
    },

    /**
     * Value of the 'autocomplete' field of the input
     * element.
     * @type {String}
     */
    autocomplete: {
      type: String,
      default: 'off'
    },

    /**
     * Tells vue-select what key to use when generating option
     * values when each `option` is an object.
     * @type {String}
     */
    index: {
      type: String,
      default: null
    },

    /**
     * Callback to generate the label text. If {option}
     * is an object, returns option[this.label] by default.
     *
     * Label text is used for filtering comparison and
     * displaying. If you only need to adjust the
     * display, you should use the `option` and
     * `selected-option` slots.
     *
     * @type {Function}
     * @param  {Object || String} option
     * @return {String}
     */
    getOptionLabel: {
      type: Function,
      default: function _default(option) {
        if (this.index) {
          option = this.findOptionByIndexValue(option);
        }

        if (Object(_Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(option) === 'object') {
          if (!option.hasOwnProperty(this.label)) {
            return console.warn("[vue-select warn]: Label key \"option.".concat(this.label, "\" does not") + " exist in options object ".concat(_Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_7___default()(option), ".\n") + 'http://sagalbot.github.io/vue-select/#ex-labels');
          }

          return option[this.label];
        }

        return option;
      }
    },

    /**
     * An optional callback function that is called each time the selected
     * value(s) change. When integrating with Vuex, use this callback to trigger
     * an action, rather than using :value.sync to retreive the selected value.
     * @type {Function}
     * @param {Object || String} val
     */
    onChange: {
      type: Function,
      default: function _default(val) {
        this.$emit('change', val);
      }
    },
    onInput: {
      type: Function,
      default: function _default(val) {
        this.$emit('input', val);
      }
    },

    /**
     * Select the current value if selectOnTab is enabled
     */
    onTab: {
      type: Function,
      default: function _default() {
        if (this.selectOnTab) {
          this.typeAheadSelect();
        }
      }
    },

    /**
     * Enable/disable creating options from searchInput.
     * @type {Boolean}
     */
    taggable: {
      type: Boolean,
      default: false
    },

    /**
     * Set the tabindex for the input field.
     * @type {Number}
     */
    tabindex: {
      type: Number,
      default: null
    },

    /**
     * When true, newly created tags will be added to
     * the options list.
     * @type {Boolean}
     */
    pushTags: {
      type: Boolean,
      default: false
    },

    /**
     * When true, existing options will be filtered
     * by the search text. Should not be used in conjunction
     * with taggable.
     * @type {Boolean}
     */
    filterable: {
      type: Boolean,
      default: true
    },

    /**
     * Callback to determine if the provided option should
     * match the current search text. Used to determine
     * if the option should be displayed.
     * @type   {Function}
     * @param  {Object || String} option
     * @param  {String} label
     * @param  {String} search
     * @return {Boolean}
     */
    filterBy: {
      type: Function,
      default: function _default(option, label, search) {
        return (label || '').toLowerCase().indexOf(search.toLowerCase()) > -1;
      }
    },

    /**
     * Callback to filter results when search text
     * is provided. Default implementation loops
     * each option, and returns the result of
     * this.filterBy.
     * @type   {Function}
     * @param  {Array} list of options
     * @param  {String} search text
     * @param  {Object} vSelect instance
     * @return {Boolean}
     */
    filter: {
      "type": Function,
      default: function _default(options, search) {
        var _this = this;

        return options.filter(function (option) {
          var label = _this.getOptionLabel(option);

          if (typeof label === 'number') {
            label = label.toString();
          }

          return _this.filterBy(option, label, search);
        });
      }
    },

    /**
     * User defined function for adding Options
     * @type {Function}
     */
    createOption: {
      type: Function,
      default: function _default(newOption) {
        if (Object(_Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(this.mutableOptions[0]) === 'object') {
          newOption = Object(_Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])({}, this.label, newOption);
        }

        this.$emit('option:created', newOption);
        return newOption;
      }
    },

    /**
     * When false, updating the options will not reset the select value
     * @type {Boolean}
     */
    resetOnOptionsChange: {
      type: Boolean,
      default: false
    },

    /**
     * Disable the dropdown entirely.
     * @type {Boolean}
     */
    noDrop: {
      type: Boolean,
      default: false
    },

    /**
     * Sets the id of the input element.
     * @type {String}
     * @default {null}
     */
    inputId: {
      type: String
    },

    /**
     * Sets RTL support. Accepts 'ltr', 'rtl', 'auto'.
     * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir
     * @type {String}
     * @default 'auto'
     */
    dir: {
      type: String,
      default: 'auto'
    },

    /**
     * When true, hitting the 'tab' key will select the current select value
     * @type {Boolean}
     */
    selectOnTab: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      search: '',
      open: false,
      mutableValue: null,
      mutableOptions: []
    };
  },
  watch: {
    /**
     * When the value prop changes, update
     * the internal mutableValue.
     * @param  {mixed} val
     * @return {void}
     */
    value: function value(val) {
      this.mutableValue = val;
    },

    /**
     * Maybe run the onChange callback.
     * @param  {string|object} val
     * @param  {string|object} old
     * @return {void}
     */
    mutableValue: function mutableValue(val, old) {
      if (this.multiple) {
        this.onChange ? this.onChange(val) : null;
      } else {
        this.onChange && val !== old ? this.onChange(val) : null;
      }
    },

    /**
     * When options change, update
     * the internal mutableOptions.
     * @param  {array} val
     * @return {void}
     */
    options: function options(val) {
      this.mutableOptions = val;
    },

    /**
     * Maybe reset the mutableValue
     * when mutableOptions change.
     * @return {[type]} [description]
     */
    mutableOptions: function mutableOptions() {
      if (!this.taggable && this.resetOnOptionsChange) {
        this.mutableValue = this.multiple ? [] : null;
      }
    },

    /**
     * Always reset the mutableValue when
     * the multiple prop changes.
     * @param  {Boolean} val
     * @return {void}
     */
    multiple: function multiple(val) {
      this.mutableValue = val ? [] : null;
    }
  },

  /**
   * Clone props into mutable values,
   * attach any event listeners.
   */
  created: function created() {
    this.mutableValue = this.value;
    this.mutableOptions = this.options.slice(0);
    this.mutableLoading = this.loading;
    this.$on('option:created', this.maybePushTag);
  },
  methods: {
    /**
     * Select a given option.
     * @param  {Object|String} option
     * @return {void}
     */
    select: function select(option) {
      if (!this.isOptionSelected(option)) {
        if (this.taggable && !this.optionExists(option)) {
          option = this.createOption(option);
        }

        if (this.index) {
          if (!option.hasOwnProperty(this.index)) {
            return console.warn("[vue-select warn]: Index key \"option.".concat(this.index, "\" does not") + " exist in options object ".concat(_Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_7___default()(option), "."));
          }

          option = option[this.index];
        }

        if (this.multiple && !this.mutableValue) {
          this.mutableValue = [option];
        } else if (this.multiple) {
          this.mutableValue = [].concat(Object(_Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(this.mutableValue), [option]);
        } else {
          this.mutableValue = option;
        }

        this.onInput(this.mutableValue);
      }

      this.onAfterSelect(option);
    },

    /**
     * De-select a given option.
     * @param  {Object|String} option
     * @return {void}
     */
    deselect: function deselect(option) {
      var _this2 = this;

      if (this.multiple) {
        var ref = -1;
        this.mutableValue.forEach(function (val) {
          if (val === option || _this2.index && val === option[_this2.index] || Object(_Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(val) === 'object' && val[_this2.label] === option[_this2.label]) {
            ref = val;
          }
        });
        this.mutableValue = this.mutableValue.filter(function (entry) {
          return entry !== ref;
        });
      } else {
        this.mutableValue = null;
      }

      this.onInput(this.mutableValue);
    },

    /**
     * Clears the currently selected value(s)
     * @return {void}
     */
    clearSelection: function clearSelection() {
      this.mutableValue = this.multiple ? [] : null;
      this.onInput(this.mutableValue);
    },

    /**
     * Called from this.select after each selection.
     * @param  {Object|String} option
     * @return {void}
     */
    onAfterSelect: function onAfterSelect(option) {
      if (this.closeOnSelect) {
        this.open = !this.open;
        this.$refs.search.blur();
      }

      if (this.clearSearchOnSelect) {
        this.search = '';
      }
    },

    /**
     * Toggle the visibility of the dropdown menu.
     * @param  {Event} e
     * @return {void}
     */
    toggleDropdown: function toggleDropdown(e) {
      if (e.target === this.$refs.openIndicator || e.target === this.$refs.search || e.target === this.$refs.toggle || e.target.classList.contains('selected-tag') || e.target === this.$el) {
        if (this.open) {
          this.$refs.search.blur(); // dropdown will close on blur
        } else {
          if (!this.disabled) {
            this.open = true;
            this.$refs.search.focus();
          }
        }
      }
    },

    /**
     * Check if the given option is currently selected.
     * @param  {Object|String}  option
     * @return {Boolean}        True when selected | False otherwise
     */
    isOptionSelected: function isOptionSelected(option) {
      var _this3 = this;

      return this.valueAsArray.some(function (value) {
        if (Object(_Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(value) === 'object') {
          return _this3.optionObjectComparator(value, option);
        }

        return value === option || value === option[_this3.index];
      });
    },

    /**
     * Determine if two option objects are matching.
     *
     * @param value {Object}
     * @param option {Object}
     * @returns {boolean}
     */
    optionObjectComparator: function optionObjectComparator(value, option) {
      if (this.index && value === option[this.index]) {
        return true;
      } else if (value[this.label] === option[this.label] || value[this.label] === option) {
        return true;
      } else if (this.index && value[this.index] === option[this.index]) {
        return true;
      }

      return false;
    },

    /**
     * Finds an option from this.options
     * where option[this.index] matches
     * the passed in value.
     *
     * @param value {Object}
     * @returns {*}
     */
    findOptionByIndexValue: function findOptionByIndexValue(value) {
      var _this4 = this;

      this.options.forEach(function (_option) {
        if (_Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_7___default()(_option[_this4.index]) === _Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_core_js_json_stringify__WEBPACK_IMPORTED_MODULE_7___default()(value)) {
          value = _option;
        }
      });
      return value;
    },

    /**
     * If there is any text in the search input, remove it.
     * Otherwise, blur the search input to close the dropdown.
     * @return {void}
     */
    onEscape: function onEscape() {
      if (!this.search.length) {
        this.$refs.search.blur();
      } else {
        this.search = '';
      }
    },

    /**
     * Close the dropdown on blur.
     * @emits  {search:blur}
     * @return {void}
     */
    onSearchBlur: function onSearchBlur() {
      if (this.mousedown && !this.searching) {
        this.mousedown = false;
      } else {
        if (this.clearSearchOnBlur) {
          this.search = '';
        }

        this.closeSearchOptions();
        return;
      } // Fixed bug where no-options message could not be closed


      if (this.search.length === 0 && this.options.length === 0) {
        this.closeSearchOptions();
        return;
      }
    },

    /**
     * 'Private' function to close the search options
     * @emits  {search:blur}
     * @returns {void}
     */
    closeSearchOptions: function closeSearchOptions() {
      this.open = false;
      this.$emit('search:blur');
    },

    /**
     * Open the dropdown on focus.
     * @emits  {search:focus}
     * @return {void}
     */
    onSearchFocus: function onSearchFocus() {
      this.open = true;
      this.$emit('search:focus');
    },

    /**
     * Delete the value on Delete keypress when there is no
     * text in the search input, & there's tags to delete
     * @return {this.value}
     */
    maybeDeleteValue: function maybeDeleteValue() {
      if (!this.$refs.search.value.length && this.mutableValue && this.clearable) {
        this.mutableValue = this.multiple ? this.mutableValue.slice(0, -1) : null;
      }
    },

    /**
     * Determine if an option exists
     * within this.mutableOptions array.
     *
     * @param  {Object || String} option
     * @return {boolean}
     */
    optionExists: function optionExists(option) {
      var _this5 = this;

      var exists = false;
      this.mutableOptions.forEach(function (opt) {
        if (Object(_Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(opt) === 'object' && opt[_this5.label] === option) {
          exists = true;
        } else if (opt === option) {
          exists = true;
        }
      });
      return exists;
    },

    /**
     * If push-tags is true, push the
     * given option to mutableOptions.
     *
     * @param  {Object || String} option
     * @return {void}
     */
    maybePushTag: function maybePushTag(option) {
      if (this.pushTags) {
        this.mutableOptions.push(option);
      }
    },

    /**
     * Event-Handler to help workaround IE11 (probably fixes 10 as well)
     * firing a `blur` event when clicking
     * the dropdown's scrollbar, causing it
     * to collapse abruptly.
     * @return {void}
     */
    onMousedown: function onMousedown() {
      this.mousedown = true;
    },
    onMouseup: function onMouseup() {
      this.mousedown = false;
    }
  },
  computed: {
    /**
     * Classes to be output on .dropdown
     * @return {Object}
     */
    dropdownClasses: function dropdownClasses() {
      return {
        open: this.dropdownOpen,
        single: !this.multiple,
        searching: this.searching,
        searchable: this.searchable,
        unsearchable: !this.searchable,
        loading: this.mutableLoading,
        rtl: this.dir === 'rtl',
        // This can be removed - styling is handled by `dir="rtl"` attribute
        disabled: this.disabled
      };
    },

    /**
     * If search text should clear on blur
     * @return {Boolean} True when single and clearSearchOnSelect
     */
    clearSearchOnBlur: function clearSearchOnBlur() {
      return this.clearSearchOnSelect && !this.multiple;
    },

    /**
     * Return the current state of the
     * search input
     * @return {Boolean} True if non empty value
     */
    searching: function searching() {
      return !!this.search;
    },

    /**
     * Return the current state of the
     * dropdown menu.
     * @return {Boolean} True if open
     */
    dropdownOpen: function dropdownOpen() {
      return this.noDrop ? false : this.open && !this.mutableLoading;
    },

    /**
     * Return the placeholder string if it's set
     * & there is no value selected.
     * @return {String} Placeholder text
     */
    searchPlaceholder: function searchPlaceholder() {
      if (this.isValueEmpty && this.placeholder) {
        return this.placeholder;
      }
    },

    /**
     * The currently displayed options, filtered
     * by the search elements value. If tagging
     * true, the search text will be prepended
     * if it doesn't already exist.
     *
     * @return {array}
     */
    filteredOptions: function filteredOptions() {
      if (!this.filterable && !this.taggable) {
        return this.mutableOptions.slice();
      }

      var options = this.search.length ? this.filter(this.mutableOptions, this.search, this) : this.mutableOptions;

      if (this.taggable && this.search.length && !this.optionExists(this.search)) {
        options.unshift(this.search);
      }

      return options;
    },

    /**
     * Check if there aren't any options selected.
     * @return {Boolean}
     */
    isValueEmpty: function isValueEmpty() {
      if (this.mutableValue) {
        if (Object(_Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(this.mutableValue) === 'object') {
          return !_Users_dannyr_workspaces_jfrog_ui_essentials_node_modules_babel_runtime_corejs2_core_js_object_keys__WEBPACK_IMPORTED_MODULE_0___default()(this.mutableValue).length;
        }

        return !this.valueAsArray.length;
      }

      return true;
    },

    /**
     * Return the current value in array format.
     * @return {Array}
     */
    valueAsArray: function valueAsArray() {
      if (this.multiple && this.mutableValue) {
        return this.mutableValue;
      } else if (this.mutableValue) {
        return [].concat(this.mutableValue);
      }

      return [];
    },

    /**
     * Determines if the clear button should be displayed.
     * @return {Boolean}
     */
    showClearButton: function showClearButton() {
      return !this.multiple && this.clearable && !this.open && this.mutableValue != null;
    }
  }
});

/***/ })

}]);
//# sourceMappingURL=jfrog-ui-essentials.umd.vendors-chunks~a510c8f3.js.map