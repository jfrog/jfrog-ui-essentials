{"version":3,"sources":["webpack://jfrog-ui-essentials/./src/components/JfCodeMirrorComponent/index.vue?17c1","webpack://jfrog-ui-essentials/./src/components/JfCodeMirrorComponent/config.js","webpack://jfrog-ui-essentials/src/components/JfCodeMirrorComponent/index.vue","webpack://jfrog-ui-essentials/./src/components/JfCodeMirrorComponent/index.vue?a780","webpack://jfrog-ui-essentials/./src/components/JfCodeMirrorComponent/index.vue","webpack://jfrog-ui-essentials/./src/components/JfCodeMirrorComponent/index.vue?fe27"],"names":["render","_vm","this","_h","$createElement","_c","_self","class","enableCopyToClipboard","formattedModel","clipboardCopyModel","staticClass","codeMirrorIsWithScroll","attrs","clipboardCopyEntityName","_e","editorOptions","on","codeMirrorLoaded","model","value","callback","$$v","expression","staticRenderFns","aliasMime","newMime","existingMime","CodeMirror","defineMIME","mimeModes","defineCodeMirrorMimes","defineCodeMirrorAqlMode","defineMode","urlRegex","inApiKey","token","stream","state","match","ret","next","defineCodeMirrorLinkOverlay","config","parserConfig","linkOverlay","overlayMode","getMode","mimeType","codeMirrorAsciidocConfig","HighlightRules","identifierRe","quoteRule","ch","prefix","test","$rules","regex","include","noEscape","tokenMap","macro","tableBlock","titleUnderline","singleLineTitle","pageBreak","option","otherBlock","literal","optionalTitle","escape","link","stateRules","i","length","rule","args","concat","filter","x","splice","apply","MAX_TOKEN_COUNT","Tokenizer","rules","key","states","regExps","matchMappings","ruleRegExps","matchTotal","mapping","defaultToken","flag","splitterRurles","caseInsensitive","RegExp","toString","slice","adjustedregex","matchcount","exec","Array","isArray","Error","tokenArray","onMatch","$arrayTokens","$applyToken","replace","digit","parseInt","removeCapturingGroups","splitRegex","push","forEach","createSplitterRegexp","join","$setMaxTokenCount","m","str","values","types","type","tokens","l","src","r","y","indexOf","stack","inChClass","lastCapture","esc","parenOpen","parenClose","square","index","end","start","substr","substring","getLineTokens","line","startState","currentState","re","lastIndex","skipped","undefined","window","console","error","merge","unshift","call","prototype","tokenFromAceToken","empty","text","keyword","control","operator","constant","numeric","character","variable","parameter","language","comment","percentage","block","doc","string","quoted","single","double","triple","unquoted","interpolated","regexp","meta","support","markup","underline","strong","heading","em","list","numbered","unnumbered","quote","raw","invalid","illegal","deprecated","cmTokenFromAceTokens","consumeToken","plannedToken","plannedTokens","shift","split","matchToken","current","currentLine","tokenized","tokenizer","aceHighlightRules","blankLine","initCodemirrorConfig","_","isUndefined","component"],"mappings":"+MAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACA,EAAG,MAAM,CAACE,MAAM,CAAC,4BAA8BN,EAAIO,wBAAwB,CAAEP,EAAIO,uBAAyBP,EAAIQ,iBAAmBR,EAAIS,mBAAoBL,EAAG,eAAe,CAACM,YAAY,8BAA8BJ,MAAM,CAAC,mBAAmBN,EAAIW,0BAA0BC,MAAM,CAAC,eAAeZ,EAAIQ,eAAe,cAAcR,EAAIa,yBAA2B,UAAUb,EAAIc,KAAMd,EAAIO,uBAAyBP,EAAIS,mBAAoBL,EAAG,eAAe,CAACM,YAAY,8BAA8BJ,MAAM,CAAC,mBAAmBN,EAAIW,0BAA0BC,MAAM,CAAC,eAAeZ,EAAIS,mBAAmB,cAAcT,EAAIa,yBAA2B,UAAUb,EAAIc,KAAKV,EAAG,aAAa,CAACQ,MAAM,CAAC,QAAUZ,EAAIe,eAAeC,GAAG,CAAC,MAAQhB,EAAIiB,kBAAkBC,MAAM,CAACC,MAAOnB,EAAkB,eAAEoB,SAAS,SAAUC,GAAMrB,EAAIQ,eAAea,GAAKC,WAAW,qBAAqB,MAC/7BC,EAAkB,G,qOCDtB,SAASC,EAAUC,EAASC,EAAcC,GACtCA,EAAWC,WAAWH,EAASE,EAAWE,UAAUH,IAGxD,SAASI,EAAsBH,GAC3BH,EAAU,qBAAsB,cAAeG,GAC/CH,EAAU,MAAO,WAAYG,GAGjC,SAASI,EAAwBJ,GAC7BA,EAAWK,WAAW,OAAO,WACzB,IAAMC,EAAW,0DACbC,GAAW,EACf,MAAO,CACHC,MADG,SACGC,EAAQC,GAEV,GAAID,EAAOE,MAAM,iCACb,MAAO,mBACT,GAAIF,EAAOE,MAAM,qBAEf,OADAJ,GAAW,EACJ,aACT,GAAIE,EAAOE,MAAM,KAEf,OADAJ,GAAW,EACJ,KACT,GAAIE,EAAOE,MAAM,wCACf,MAAO,cACT,GAAIF,EAAOE,MAAM,6FACf,MAAO,gBACT,GAAIF,EAAOE,MAAM,8BACf,MAAO,aACT,GAAIF,EAAOE,MAAM,mBACf,MAAO,eACT,GAAIF,EAAOE,MAAML,GACf,MAAO,UAEX,IAAIM,EAAM,KAKV,OAJIL,IAAaE,EAAOE,MAAM,OAC1BC,EAAM,WAEVH,EAAOI,OACAD,OAQvB,SAASE,EAA4Bd,GACjC,IAAMM,EAAW,0DACjBN,EAAWK,WAAW,SAAS,SAACU,EAAQC,GACpC,IAAMC,EAAc,CAChBT,MADgB,SACVC,EAAQC,GACV,GAAID,EAAOE,MAAML,GACb,MAAO,OAEX,MAAwB,MAAjBG,EAAOI,SAAmBJ,EAAOE,MAAML,GAAU,IAExD,OAAO,OAIf,OAAON,EAAWkB,YAAYlB,EAAWmB,QAAQJ,EAAQA,EAAOK,UAAY,YAAaH,MAGjG,SAASI,EAAyBrB,GAO9BA,EAAWK,WAAW,YAAY,SAAUU,EAAQC,GAGhD,IAAIM,EAAiB,WACjB,IAAIC,EAAe,kBAuLnB,SAASC,EAAUC,GACf,IAAIC,EAAS,KAAKC,KAAKF,GAAM,MAAQ,YACrC,OAAOC,EAASD,EAAK,KAAOA,EAAK,OAASA,EAAK,aAvLnDnD,KAAKsD,OAAS,CACV,MAAS,CACL,CAACpB,MAAO,QAASqB,MAAO,KACxB,CAACrB,MAAO,UAAWqB,MAAO,cAAehB,KAAM,gBAC/C,CAACL,MAAO,UAAWqB,MAAO,aAAchB,KAAM,gBAC9C,CAACL,MAAO,UAAWqB,MAAO,cAAehB,KAAM,oBAC/C,CAACL,MAAO,UAAWqB,MAAO,cAC1B,CAACrB,MAAO,OAAQqB,MAAO,SAEvB,CAACrB,MAAO,QAASqB,MAAO,GAAIhB,KAAM,4BAGtC,wBAA2B,CACvB,CAACiB,QAAS,gBACV,CAACtB,MAAO,UAAWqB,MAAO,UAC1B,CAACrB,MAAO,UAAWqB,MAAO,+CAE1B,CAACC,QAAS,aACV,CAACtB,MAAO,UAAWqB,MAAO,UAAWhB,KAAM,iBAC3C,CAACL,MAAO,QAASqB,MAAO,GAAIhB,KAAM,SAGtC,aAAgB,CACZ,CAACL,MAAO,cAAeqB,MAAO,cAAehB,KAAM,gBACnD,CAACL,MAAO,aAAcqB,MAAO,iBAAkBhB,KAAM,cAErD,CAACL,MAAO,UAAWqB,MAAO,kBAAmBhB,KAAM,SACnD,CAACL,MAAO,SAAUqB,MAAO,cAAehB,KAAM,SAC9C,CAACL,MAAO,YAAaqB,MAAO,UAAWhB,KAAM,SAC7C,CAACL,MAAO,UAAWqB,MAAO,cAAehB,KAAM,gBAC/C,CAACL,MAAO,iBAAkBqB,MAAO,2CAA4ChB,KAAM,SACnF,CAACL,MAAO,kBAAmBqB,MAAO,kBAAmBhB,KAAM,SAE3D,CAACL,MAAO,aAAcqB,MAAO,wBAAyBhB,KAAM,SAE5D,CAACL,MAAO,gBAAiBqB,MAAO,eAAgBhB,KAAM,UAG1D,UAAa,CACT,CACIL,MAAO,UACPqB,MAAO,6DACPhB,KAAM,YAEV,CAACL,MAAO,WAAYqB,MAAO,0BAA2BhB,KAAM,YAE5D,CAACL,MAAO,UAAWqB,MAAO,UAAWhB,KAAM,UAG/C,KAAQ,CACJ,CACIL,MAAO,CAAC,OAAQ,QAChBqB,MAAO,yEAEX,CAACrB,MAAO,CAAC,OAAQ,QAASqB,MAAO,8DACjC,CAACrB,MAAO,OAAQqB,MAAO,+BACvB,CAACC,QAAS,UACV,CAACA,QAAS,gBACV,CAACtB,MAAO,UAAWqB,MAAO,SAAUhB,KAAM,oBAC1C,CACIL,MAAO,SACPqB,MAAO,+EAEX,CAACrB,MAAO,SAAUqB,MAAO,+BACzB,CAACrB,MAAO,UAAWqB,MAAO,SAE1B,CAACrB,MAAO,OAAQqB,MAAON,GACvB,CACIf,MAAO,CAAC,UAAW,SAAU,WAC7BqB,MAAO,8BAEX,CAACrB,MAAO,UAAWqB,MAAO,qBAC1B,CAACrB,MAAO,qBAAsBqB,MAAO,qBAErC,CAACrB,MAAO,gCAAiCqB,MAAO,qBAAsBhB,KAAM,QAE5E,CAACL,MAAO,UAAWqB,MAAO,eAE1B,CAACrB,MAAO,UAAWqB,MAAO,0BAE1B,CAACC,QAAS,UAEV,CAACtB,MAAO,QAASqB,MAAO,QAAShB,KAAM,UAG3C,SAAY,CACR,CAACiB,QAAS,aACV,CAACA,QAAS,SAGd,cAAiB,CACb,CAACtB,MAAO,UAAWqB,MAAO,aAAchB,KAAM,iBAC9C,CAACL,MAAO,UAAWqB,MAAO,GAAIhB,KAAM,UAGxC,aAAgB,CACZ,CAACL,MAAO,UAAWqB,MAAO,cAAehB,KAAM,2BAC/C,CAACL,MAAO,mBAAoBqB,MAAO,UACnC,CAACrB,MAAO,UAAWqB,MAAO,SAC1B,CAACrB,MAAO,UAAWqB,MAAO,MAE9B,aAAgB,CACZ,CAACrB,MAAO,UAAWqB,MAAO,aAAchB,KAAM,2BAC9C,CAACL,MAAO,mBAAoBqB,MAAO,UACnC,CAACrB,MAAO,UAAWqB,MAAO,SAC1B,CAACrB,MAAO,UAAWqB,MAAO,MAE9B,iBAAoB,CAChB,CAACrB,MAAO,UAAWqB,MAAO,cAAehB,KAAM,2BAC/C,CAACL,MAAO,UAAWqB,MAAON,EAAe,SACzC,CAACO,QAAS,UACV,CAACtB,MAAO,UAAWqB,MAAO,MAG9B,iBAAoB,CAChB,CAACrB,MAAO,UAAWqB,MAAO,UAAWhB,KAAM,2BAC3C,CAACL,MAAO,UAAWqB,MAAO,QAAShB,KAAM,2BACzC,CAACL,MAAO,UAAWqB,MAAON,EAAe,SACzC,CAACO,QAAS,WAGd,aAAgB,CACZ,CAACtB,MAAO,cAAeqB,MAAO,cAAehB,KAAM,2BACnD,CAACL,MAAO,cAAeqB,MAAO,SAElC,WAAc,CACV,CAACrB,MAAO,aAAcqB,MAAO,kBAAmBhB,KAAM,2BACtD,CAACL,MAAO,aAAcqB,MAAO,iBAAkBhB,KAAM,mBACrD,CAACL,MAAO,aAAcqB,MAAO,MAC7B,CAACC,QAAS,OAAQC,UAAU,IAEhC,gBAAmB,CACf,CAACvB,MAAO,aAAcqB,MAAO,iBAAkBhB,KAAM,cACrD,CAACL,MAAO,aAAcqB,MAAO,iBAAkBhB,KAAM,2BACrD,CAACL,MAAO,aAAcqB,MAAO,OAEjC,OAAU,CACN,CAACrB,MAAO,QAASqB,MAAO,cACxB,CACIrB,MAAO,CAAC,OAAQ,SAAU,OAAQ,qBAAsB,QACxDqB,MAAO,6BAEX,CACIrB,MAAO,CAAC,OAAQ,oBAAqB,UAAW,UAChDqB,MAAO,mDAEX,CACIrB,MAAO,CAAC,oBAAqB,UAAW,UACxCqB,MAAO,kDAEX,CAACrB,MAAO,CAAC,oBAAqB,WAAYqB,MAAO,uCACjD,CAACrB,MAAO,UAAWqB,MAAO,kBAG9B,OAAU,CACN,CAACrB,MAAO,gBAAiBqB,MAAO,iBAChC,CAACrB,MAAO,gBAAiBqB,MAAOL,EAAU,MAE1C,CAAChB,MAAO,eAAgBqB,MAAO,qBAC/B,CAACrB,MAAO,eAAgBqB,MAAOL,EAAU,QAEzC,CAAChB,MAAO,UAAWqB,MAAO,qBAC1B,CAACrB,MAAO,UAAWqB,MAAOL,EAAU,QAEpC,CAAChB,MAAO,UAAWqB,MAAO,eAC1B,CAACrB,MAAO,UAAWqB,MAAOL,EAAU,QAEpC,CAAChB,MAAO,UAAWqB,MAAO,iBAC1B,CAACrB,MAAO,UAAWqB,MAAOL,EAAU,MAEpC,CAAChB,MAAO,UAAWqB,MAAO,gBAC1B,CAACrB,MAAO,UAAWqB,MAAOL,EAAU,QACpC,CAAChB,MAAO,UAAWqB,MAAO,aAC1B,CAACrB,MAAO,UAAWqB,MAAOL,EAAU,MAEpC,CAAChB,MAAO,UAAWqB,MAAO,OAC1B,CAACrB,MAAO,UAAWqB,MAAO,qBAYlC,IAAIG,EAAW,CACXC,MAAO,qBACPC,WAAY,cACZC,eAAgB,iBAChBC,gBAAiB,iBACjBC,UAAW,SACXC,OAAQ,gBACRC,WAAY,cACZC,QAAS,mBACTC,cAAe,mBACfC,OAAQ,2BACRC,KAAM,yBAGV,IAAK,IAAIjC,KAASpC,KAAKsD,OAEnB,IADA,IAAIgB,EAAatE,KAAKsD,OAAOlB,GACpBmC,EAAID,EAAWE,OAAQD,KAAM,CAClC,IAAIE,EAAOH,EAAWC,GACtB,GAAIE,EAAKjB,SAA0B,iBAARiB,EAAkB,CACzC,IAAIC,EAAO,CAACH,EAAG,GAAGI,OAAO3E,KAAKsD,OAAOmB,EAAKjB,SAAWiB,IACjDA,EAAKhB,WACLiB,EAAOA,EAAKE,QAAO,SAAUC,GACzB,OAAQA,EAAEtC,SAGlB+B,EAAWQ,OAAOC,MAAMT,EAAYI,QAC7BD,EAAKvC,SAASwB,IACrBe,EAAKvC,MAAQwB,EAASe,EAAKvC,UAUvC8C,EAAkB,IAClBC,EAAY,SAAUC,GAKtB,IAAK,IAAIC,KAJTnF,KAAKoF,OAASF,EAEdlF,KAAKqF,QAAU,GACfrF,KAAKsF,cAAgB,GACLtF,KAAKoF,OAAQ,CAQzB,IAPA,IAAIhD,EAAQpC,KAAKoF,OAAOD,GACpBI,EAAc,GACdC,EAAa,EACbC,EAAUzF,KAAKsF,cAAcH,GAAO,CAACO,aAAc,QACnDC,EAAO,IAEPC,EAAiB,GACZrB,EAAI,EAAGA,EAAInC,EAAMoC,OAAQD,IAAK,CACnC,IAAIE,EAAOrC,EAAMmC,GAKjB,GAJIE,EAAKiB,eACLD,EAAQC,aAAejB,EAAKiB,cAC5BjB,EAAKoB,kBACLF,EAAO,MACO,MAAdlB,EAAKlB,MAAT,CAGIkB,EAAKlB,iBAAiBuC,SACtBrB,EAAKlB,MAAQkB,EAAKlB,MAAMwC,WAAWC,MAAM,GAAI,IAIjD,IAAIC,EAAgBxB,EAAKlB,MACrB2C,EAAa,IAAIJ,OAAO,OAASG,EAAgB,UAAUE,KAAK,KAAK3B,OAAS,EAClF,GAAI4B,MAAMC,QAAQ5B,EAAKvC,OACnB,GAAyB,GAArBuC,EAAKvC,MAAMsC,QAA6B,GAAd0B,EAC1BzB,EAAKvC,MAAQuC,EAAKvC,MAAM,OACrB,IAAIgE,EAAa,GAAKzB,EAAKvC,MAAMsC,OACpC,MAAM,IAAI8B,MAAM,2CACZ7B,EAAKvC,MAAQ,OAASuC,EAAKlB,MAAQ,qBAChC2C,EAAa,GAAK,KAAOzB,EAAKvC,MAAMsC,QAE3CC,EAAK8B,WAAa9B,EAAKvC,MACvBuC,EAAKvC,MAAQ,KACbuC,EAAK+B,QAAUxG,KAAKyG,iBAEI,mBAAdhC,EAAKvC,OAAwBuC,EAAK+B,UAE5C/B,EAAK+B,QADLN,EAAa,EACElG,KAAK0G,YAELjC,EAAKvC,OAGxBgE,EAAa,IACT,OAAO7C,KAAKoB,EAAKlB,OAEjB0C,EAAgBxB,EAAKlB,MAAMoD,QAAQ,eAAe,SAAUtE,EAAOuE,GAC/D,MAAO,MAAQC,SAASD,EAAO,IAAMpB,EAAa,OAGtDU,EAAa,EACbD,EAAgBjG,KAAK8G,sBAAsBrC,EAAKlB,QAE/CkB,EAAKsC,YAAmC,iBAAdtC,EAAKvC,OAChC0D,EAAeoB,KAAKvC,IAG5BgB,EAAQD,GAAcjB,EACtBiB,GAAcU,EAEdX,EAAYyB,KAAKf,GAGZxB,EAAK+B,UACN/B,EAAK+B,QAAU,OAGvBZ,EAAeqB,SAAQ,SAAUxC,GAC7BA,EAAKsC,WAAa/G,KAAKkH,qBAAqBzC,EAAKlB,MAAOoC,KACzD3F,MAEHA,KAAKqF,QAAQF,GAAO,IAAIW,OAAO,IAAMP,EAAY4B,KAAK,OAAS,QAASxB,MAIhF,WACI3F,KAAKoH,kBAAoB,SAAUC,GAC/BrC,EAAsB,EAAJqC,GAGtBrH,KAAK0G,YAAc,SAAUY,GACzB,IAAIC,EAASvH,KAAK+G,WAAWZ,KAAKmB,GAAKtB,MAAM,GACzCwB,EAAQxH,KAAKkC,MAAM6C,MAAM/E,KAAMuH,GAGnC,GAAqB,kBAAVC,EACP,MAAO,CAAC,CAACC,KAAMD,EAAOtG,MAAOoG,IAGjC,IADA,IAAII,EAAS,GACJnD,EAAI,EAAGoD,EAAIH,EAAMhD,OAAQD,EAAIoD,EAAGpD,IACjCgD,EAAOhD,KACPmD,EAAOA,EAAOlD,QAAU,CACpBiD,KAAMD,EAAMjD,GACZrD,MAAOqG,EAAOhD,KAG1B,OAAOmD,GAGP1H,KAAKyG,aAAe,SAAUa,GAC1B,IAAKA,EACD,MAAO,GACX,IAAIC,EAASvH,KAAK+G,WAAWZ,KAAKmB,GAClC,IAAKC,EACD,MAAO,OAGX,IAFA,IAAIG,EAAS,GACTF,EAAQxH,KAAKuG,WACRhC,EAAI,EAAGoD,EAAIH,EAAMhD,OAAQD,EAAIoD,EAAGpD,IACjCgD,EAAOhD,EAAI,KACXmD,EAAOA,EAAOlD,QAAU,CACpBiD,KAAMD,EAAMjD,GACZrD,MAAOqG,EAAOhD,EAAI,KAG9B,OAAOmD,GAGf1H,KAAK8G,sBAAwB,SAAUc,GACnC,IAAIC,EAAID,EAAIjB,QACR,2CACA,SAAU9B,EAAGiD,GACT,OAAOA,EAAI,MAAQjD,KAG3B,OAAOgD,GAGX7H,KAAKkH,qBAAuB,SAAUU,EAAKjC,GACvC,IAA2B,GAAvBiC,EAAIG,QAAQ,OAAc,CAC1B,IAAIC,EAAQ,EACRC,GAAY,EACZC,EAAc,GAClBN,EAAIjB,QAAQ,wCAAwC,SAAUU,EAAGc,EAAKC,EAAWC,EAAYC,EAAQC,GAkBjG,OAjBIN,EACAA,EAAsB,KAAVK,EACLA,EACPL,GAAY,EACLI,GACHL,GAASE,EAAYF,QACrBE,EAAYM,IAAMD,EAAQ,EAC1BL,EAAYF,OAAS,GAEzBA,KACOI,IACPJ,IACwB,GAApBI,EAAU5D,SACV0D,EAAYF,MAAQA,EACpBE,EAAYO,MAAQF,IAGrBlB,KAGY,MAAnBa,EAAYM,KAAe,QAAQnF,KAAKuE,EAAIc,OAAOR,EAAYM,QAC/DZ,EAAMA,EAAIe,UAAU,EAAGT,EAAYO,OAASb,EAAIc,OAAOR,EAAYM,MAE3E,OAAO,IAAI1C,OAAO8B,GAAMjC,GAAQ,IAAIgB,QAAQ,IAAK,MAOrD3G,KAAK4I,cAAgB,SAAUC,EAAMC,GACjC,GAAIA,GAAmC,iBAAdA,EAAwB,CAC7C,IAAId,EAAQc,EAAW9C,MAAM,GAC7B8C,EAAad,EAAM,QAEfA,EAAQ,GAEhB,IAAIe,EAAeD,GAAc,QAC7B1G,EAAQpC,KAAKoF,OAAO2D,GACnB3G,IACD2G,EAAe,QACf3G,EAAQpC,KAAKoF,OAAO2D,IAExB,IAAItD,EAAUzF,KAAKsF,cAAcyD,GAC7BC,EAAKhJ,KAAKqF,QAAQ0D,GACtBC,EAAGC,UAAY,EAEf,IAAI5G,EAAOqF,EAAS,GAChBuB,EAAY,EAEZ/G,EAAQ,CAACuF,KAAM,KAAMvG,MAAO,IAEhC,MAAOmB,EAAQ2G,EAAG7C,KAAK0C,GAAO,CAC1B,IAAIpB,EAAOhC,EAAQC,aACfjB,EAAO,KACPvD,EAAQmB,EAAM,GACdkG,EAAQS,EAAGC,UAEf,GAAIV,EAAQrH,EAAMsD,OAASyE,EAAW,CAClC,IAAIC,EAAUL,EAAKF,UAAUM,EAAWV,EAAQrH,EAAMsD,QAClDtC,EAAMuF,MAAQA,EACdvF,EAAMhB,OAASgI,GAEXhH,EAAMuF,MACNC,EAAOV,KAAK9E,GAChBA,EAAQ,CAACuF,KAAMA,EAAMvG,MAAOgI,IAIpC,IAAK,IAAI3E,EAAI,EAAGA,EAAIlC,EAAMmC,OAAS,EAAGD,IAClC,QAAqB4E,IAAjB9G,EAAMkC,EAAI,GAAd,CAGAE,EAAOrC,EAAMqD,EAAQlB,IAGjBkD,EADAhD,EAAK+B,QACE/B,EAAK+B,QAAQtF,EAAO6H,EAAcf,GAElCvD,EAAKvC,MAEZuC,EAAKlC,OAEDwG,EADoB,iBAAbtE,EAAKlC,KACGkC,EAAKlC,KAELkC,EAAKlC,KAAKwG,EAAcf,GAE3C5F,EAAQpC,KAAKoF,OAAO2D,GACf3G,IACDgH,OAAOC,SAAWA,QAAQC,OAASD,QAAQC,MAAMP,EAAc,iBAC/DA,EAAe,QACf3G,EAAQpC,KAAKoF,OAAO2D,IAExBtD,EAAUzF,KAAKsF,cAAcyD,GAC7BE,EAAYV,EACZS,EAAKhJ,KAAKqF,QAAQ0D,GAClBC,EAAGC,UAAYV,GAEnB,MAGJ,GAAIrH,EACA,GAAmB,iBAARuG,EACDhD,IAAuB,IAAfA,EAAK8E,OAAoBrH,EAAMuF,OAASA,GAG9CvF,EAAMuF,MACNC,EAAOV,KAAK9E,GAChBA,EAAQ,CAACuF,KAAMA,EAAMvG,MAAOA,IAJ5BgB,EAAMhB,OAASA,OAMhB,GAAIuG,EAAM,CACTvF,EAAMuF,MACNC,EAAOV,KAAK9E,GAChBA,EAAQ,CAACuF,KAAM,KAAMvG,MAAO,IAC5B,IAASqD,EAAI,EAAGA,EAAIkD,EAAKjD,OAAQD,IAC7BmD,EAAOV,KAAKS,EAAKlD,IAI7B,GAAI0E,GAAaJ,EAAKrE,OAClB,MAIJ,GAFAyE,EAAYV,EAERb,EAAOlD,OAASQ,EAAiB,CAEjC,MAAOiE,EAAYJ,EAAKrE,OAChBtC,EAAMuF,MACNC,EAAOV,KAAK9E,GAChBA,EAAQ,CACJhB,MAAO2H,EAAKF,UAAUM,EAAWA,GAAa,KAC9CxB,KAAM,YAGdsB,EAAe,QACff,EAAQ,GACR,OAWR,OAPI9F,EAAMuF,MACNC,EAAOV,KAAK9E,GAEZ8F,EAAMxD,OAAS,GACXwD,EAAM,KAAOe,GACbf,EAAMwB,QAAQT,GAEf,CACHrB,OAAQA,EACRtF,MAAO4F,EAAMxD,OAASwD,EAAQe,MAIvCU,KAAKxE,EAAUyE,WAKlB,IAAIC,EAAoB,CACpBC,MAAO,KACPC,KAAM,KAGNC,QAAS,UACTC,QAAS,UACTC,SAAU,WAGVC,SAAU,OACVC,QAAS,SACTC,UAAW,OACX/F,OAAQ,OAGRgG,SAAU,WACVC,UAAW,aACXC,SAAU,aAGVC,QAAS,UACT1B,KAAM,UACN,eAAgB,UAChB,cAAe,UACf,cAAe,UACf2B,WAAY,UACZC,MAAO,UACPC,IAAK,UAGLC,OAAQ,SACRC,OAAQ,SACRC,OAAQ,SACRC,OAAQ,SACRC,OAAQ,SACRC,SAAU,SACVC,aAAc,SACdC,OAAQ,WAERC,KAAM,UACNjH,QAAS,YACTkH,QAAS,UAGTC,OAAQ,MACRC,UAAW,OACXjH,KAAM,OACNkH,OAAQ,SACRC,QAAS,SACTC,GAAI,KACJC,KAAM,aACNC,SAAU,aACVC,WAAY,aACZC,MAAO,QACPC,IAAK,aAGLC,QAAS,QACTC,QAAS,cACTC,WAAY,SAIZC,EAAuB,SAAUxE,GAEjC,IADA,IAAIxF,EAAQ,KACHqC,EAAI,EAAGA,EAAImD,EAAOlD,OAAQD,SAEM4E,IAAjCQ,EAAkBjC,EAAOnD,MACzBrC,EAAQyH,EAAkBjC,EAAOnD,KAGzC,OAAOrC,GAIPiK,EAAe,SAAUhK,EAAQC,GACjC,IAAIgK,EAAehK,EAAMiK,cAAcC,QACvC,QAAqBnD,IAAjBiD,EACA,OAAO,KAEXjK,EAAOE,MAAM+J,EAAalL,OAC1B,IAAIwG,EAAS0E,EAAa3E,KAAK8E,MAAM,KACrC,OAAOL,EAAqBxE,IAG5B8E,EAAa,SAAUrK,EAAQC,GAE/B,GAAIA,EAAMiK,cAAc7H,OAAS,EAC7B,OAAO2H,EAAahK,EAAQC,GAIhC,IAAI2G,EAAe3G,EAAMqK,QACrBC,EAAcvK,EAAOE,MAAM,OAAO,GAAO,GACzCsK,EAAYC,EAAUhE,cAAc8D,EAAa3D,GAOrD,OAJA3G,EAAMiK,cAAgBM,EAAUjF,OAChCtF,EAAMqK,QAAUE,EAAUvK,MAGnB+J,EAAahK,EAAQC,IAI5ByK,EAAoB,IAAI7J,EACxB4J,EAAY,IAAI3H,EAAU4H,EAAkBvJ,QAEhD,MAAO,CACHwF,WAAY,WACR,MAAO,CACH2D,QAAS,QAETJ,cAAe,KAGvBS,UAAW,SAAU1K,GACjBoK,EAAW,GAAIpK,IAEnBF,MAAOsK,MAIf9K,EAAWC,WAAW,kBAAmB,YAGtC,SAASoL,EAAqBrL,GACP,qBAAfA,GAA8BsL,EAAEC,YAAYvL,KACvDqB,EAAyBrB,GACzBG,EAAsBH,GACtBc,EAA4Bd,GAC5BI,EAAwBJ,ICzrB5B,sBAEA,OACE,KAAF,iBACE,MAAF,CACA,WACA,OACA,QACA,YACA,SACA,YACA,YACA,gBACA,aACA,aACA,wBACA,qBACA,2BAEE,YAAF,CACA,SACA,WACA,WACA,gBAEE,WAAF,CACI,WAAJ,iBAEE,KA1BF,WA2BI,MAAJ,CACM,eAAN,KACM,cAAN,OAGE,QAhCF,WAiCI,EAAJ,KACI,KAAJ,oBAEE,QApCF,WAqCI,KAAJ,eAEI,KAAJ,eACM,aAAN,EACM,UAAN,eAEM,cAAN,EACM,KAAN,mBACM,eAAN,GACM,UAAN,wBACM,SAAN,cACM,cAAN,oBAIA,gBACM,KAAN,+CAGE,WAAF,CAAI,aAAJ,gBACE,QAAF,CACI,iBADJ,SACA,GAAM,IAAN,OACA,uBAAU,EAAV,MACM,EAAN,qBAEQ,GADA,EAAR,QACA,UACU,IAAV,oCACA,uBACY,EAAZ,aACY,EAAZ,gBACY,EAAZ,cACY,EAAZ,eACY,EAAZ,4BAEY,EAAZ,uBAGQ,EAAR,sDACU,IAAV,cACA,GACY,OAAZ,0CAGQ,EAAR,kCACU,EAAV,cACU,EAAV,mCAEA,cACU,EAAV,gCACA,oBACY,EAAZ,wBAKI,eAnCJ,SAmCA,GACM,IAAN,yBACA,GACQ,KAAR,EACQ,GAAR,GACA,GAAQ,KAAR,GACA,EACQ,KAAR,2BAEQ,KAAR,2BAEM,KAAN,oBAEI,QAhDJ,SAgDA,GACM,IACE,KAAR,SACA,SACQ,OAAR,EAEM,OAAN,GAEI,aAxDJ,WAwDM,IAAN,OACA,eACA,2DACU,EAAV,qBACA,uCACc,EAAd,iBACc,EAAd,kCACc,EAAd,oBAIA,aACU,EAAV,wCAEU,EAAV,iBAEQ,EAAR,eACQ,EAAR,uBAGA,gBAMQ,KAAR,0BACQ,KAAR,gDACA,6BACY,EAAZ,uBACY,EAAZ,eACY,EAAZ,0BAGQ,KAAR,yDACU,EAAV,oBAEQ,KAAR,eACQ,KAAR,wBAjBQ,EAAR,YACQ,KAAR,gDACU,EAAV,QAkBI,oBAjGJ,WAiGM,IAAN,OACA,YACA,qBACA,gBAEM,KAAN,qBACQ,IAAR,kFACA,kCACA,SACY,EAAZ,gBAEA,cACA,yBACA,oBACU,EAAV,0BACA,aAEA,MAEI,aApHJ,WAqHM,IAAN,qFACM,KAAN,mBACM,KAAN,WAEI,iBAzHJ,WAyHM,IAAN,OACM,EAAN,mDAaQ,IAZA,IAAR,UACA,cAAY,EAAZ,4BACA,yCACA,yBAEA,KAAY,EAAZ,EAAY,EAAZ,QACA,aACU,GAAV,KACU,GAAV,IACA,GAGA,oBACU,IAAV,+BACU,OAAV,SACY,IAAZ,qBACA,eAAgB,EAAhB,YACY,EAAZ,YACA,mBACc,GAAd,EACc,GAAd,IAEA,sGACA,KAEA,oBACA,eACA,GACA,IAGQ,EAAR,sBACU,EAAV,oBACU,IAAV,mCACY,EAAZ,4BAKM,EAAN,mDACQ,IAAR,UACQ,EAAR,4BACU,IAAV,2BACY,EAAZ,6BAKI,uBA3KJ,WA4KM,IAAN,uBACM,IAAN,wEACM,OAAN,iBC3Q8V,I,wBCQ1VwL,EAAY,eACd,EACApN,EACAwB,GACA,EACA,KACA,WACA,MAIa,aAAA4L,E,oECnBf","file":"jfrog-ui-essentials.umd.min.jfCodeMirror.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{class:{'codemirror-with-clip-copy' : _vm.enableCopyToClipboard}},[(_vm.enableCopyToClipboard && _vm.formattedModel && !_vm.clipboardCopyModel)?_c('jf-clip-copy',{staticClass:\"code-mirror-copy pull-right\",class:{'scrollbar-margin':_vm.codeMirrorIsWithScroll()},attrs:{\"text-to-copy\":_vm.formattedModel,\"object-name\":_vm.clipboardCopyEntityName || 'text'}}):_vm._e(),(_vm.enableCopyToClipboard && _vm.clipboardCopyModel)?_c('jf-clip-copy',{staticClass:\"code-mirror-copy pull-right\",class:{'scrollbar-margin':_vm.codeMirrorIsWithScroll()},attrs:{\"text-to-copy\":_vm.clipboardCopyModel,\"object-name\":_vm.clipboardCopyEntityName || 'text'}}):_vm._e(),_c('codemirror',{attrs:{\"options\":_vm.editorOptions},on:{\"ready\":_vm.codeMirrorLoaded},model:{value:(_vm.formattedModel),callback:function ($$v) {_vm.formattedModel=$$v},expression:\"formattedModel\"}})],1)])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","function aliasMime(newMime, existingMime, CodeMirror) {\n    CodeMirror.defineMIME(newMime, CodeMirror.mimeModes[existingMime]);\n}\n\nfunction defineCodeMirrorMimes(CodeMirror) {\n    aliasMime('text/x-java-source', 'text/x-java', CodeMirror);\n    aliasMime('pom', 'text/xml', CodeMirror);\n}\n\nfunction defineCodeMirrorAqlMode(CodeMirror) {\n    CodeMirror.defineMode('aql', () => {\n        const urlRegex = /^https?:\\/\\/[a-zA-Z]+(\\.)?(:[0-9]+)?.+?(?=\\s|$|\"|'|>|<)/;\n        let inApiKey = false;\n        return {\n            token(stream, state) {\n\n                if (stream.match(/(?:curl|\\-\\H|\\-\\X|\\-d|POST)\\b/)) {\n                    return 'external-command';\n                } if (stream.match(/(?:X\\-Api\\-Key)\\b/)) {\n                    inApiKey = true;\n                    return 'header-tag';\n                } if (stream.match('\\'')) {\n                    inApiKey = false;\n                    return null;\n                } if (stream.match(/(?:find|include|limit|sort|offset)\\b/)) {\n                    return 'aql-keyword';\n                } if (stream.match(/(?:\\$and|\\$or|\\$ne|\\$gt|\\$gte|\\$lt|\\$lte|\\$rf|\\$msp|\\$match|\\$nmatch|\\$eq|\\$asc|\\$desc)\\b/)) {\n                    return 'aql-operators';\n                } if (stream.match(/(?:items|builds|entries)\\b/)) {\n                    return 'aql-domain';\n                } if (stream.match(/[\\{\\}\\[\\]\\(\\)]+/)) {\n                    return 'aql-brackets';\n                } if (stream.match(urlRegex)) {\n                    return 'api-url';\n                }\n                let ret = null;\n                if (inApiKey && !stream.match(':')) {\n                    ret = 'api-key';\n                }\n                stream.next();\n                return ret;\n\n            },\n        };\n\n    });\n}\n\nfunction defineCodeMirrorLinkOverlay(CodeMirror) {\n    const urlRegex = /^https?:\\/\\/[a-zA-Z]+(\\.)?(:[0-9]+)?.+?(?=\\s|$|\"|'|>|<)/;\n    CodeMirror.defineMode('links', (config, parserConfig) => {\n        const linkOverlay = {\n            token(stream, state) {\n                if (stream.match(urlRegex)) {\n                    return 'link';\n                }\n                while (stream.next() != null && !stream.match(urlRegex, false)) {\n                }\n                return null;\n            },\n        };\n\n        return CodeMirror.overlayMode(CodeMirror.getMode(config, config.mimeType || 'text/xml'), linkOverlay);\n    });\n}\nfunction codeMirrorAsciidocConfig(CodeMirror) {\n    ///\n    /// This is a third party code: https://github.com/asciidoctor/codemirror-asciidoc\n    ///\n\n    \"use strict\";\n\n    CodeMirror.defineMode(\"asciidoc\", function (config, parserConfig) {\n\n        // Ace highlight rules function imported below.\n        var HighlightRules = function () {\n            var identifierRe = \"[a-zA-Z\\u00a1-\\uffff]+\\\\b\";\n\n            this.$rules = {\n                \"start\": [\n                    {token: \"empty\", regex: /$/},\n                    {token: \"literal\", regex: /^\\.{4,}\\s*$/, next: \"listingBlock\"},\n                    {token: \"literal\", regex: /^-{4,}\\s*$/, next: \"literalBlock\"},\n                    {token: \"literal\", regex: /^\\+{4,}\\s*$/, next: \"passthroughBlock\"},\n                    {token: \"keyword\", regex: /^={4,}\\s*$/},\n                    {token: \"text\", regex: /^\\s*$/},\n                    // immediately return to the start mode without matching anything\n                    {token: \"empty\", regex: \"\", next: \"dissallowDelimitedBlock\"}\n                ],\n\n                \"dissallowDelimitedBlock\": [\n                    {include: \"paragraphEnd\"},\n                    {token: \"comment\", regex: '^//.+$'},\n                    {token: \"keyword\", regex: \"^(?:NOTE|TIP|IMPORTANT|WARNING|CAUTION):\\\\s\"},\n\n                    {include: \"listStart\"},\n                    {token: \"literal\", regex: /^\\s+.+$/, next: \"indentedBlock\"},\n                    {token: \"empty\", regex: \"\", next: \"text\"}\n                ],\n\n                \"paragraphEnd\": [\n                    {token: \"doc.comment\", regex: /^\\/{4,}\\s*$/, next: \"commentBlock\"},\n                    {token: \"tableBlock\", regex: /^\\s*[|!]=+\\s*$/, next: \"tableBlock\"},\n                    // open block, ruler\n                    {token: \"keyword\", regex: /^(?:--|''')\\s*$/, next: \"start\"},\n                    {token: \"option\", regex: /^\\[.*\\]\\s*$/, next: \"start\"},\n                    {token: \"pageBreak\", regex: /^>{3,}$/, next: \"start\"},\n                    {token: \"literal\", regex: /^\\.{4,}\\s*$/, next: \"listingBlock\"},\n                    {token: \"titleUnderline\", regex: /^(?:={2,}|-{2,}|~{2,}|\\^{2,}|\\+{2,})\\s*$/, next: \"start\"},\n                    {token: \"singleLineTitle\", regex: /^={1,6}\\s+\\S.*$/, next: \"start\"},\n\n                    {token: \"otherBlock\", regex: /^(?:\\*{2,}|_{2,})\\s*$/, next: \"start\"},\n                    // .optional title\n                    {token: \"optionalTitle\", regex: /^\\.[^.\\s].+$/, next: \"start\"}\n                ],\n\n                \"listStart\": [\n                    {\n                        token: \"keyword\",\n                        regex: /^\\s*(?:\\d+\\.|[a-zA-Z]\\.|[ixvmIXVM]+\\)|\\*{1,5}|-|\\.{1,5})\\s/,\n                        next: \"listText\"\n                    },\n                    {token: \"meta.tag\", regex: /^.+(?::{2,4}|;;)(?: |$)/, next: \"listText\"},\n                    // continuation\n                    {token: \"keyword\", regex: /^\\+\\s*$/, next: \"start\"}\n                ],\n\n                \"text\": [\n                    {\n                        token: [\"link\", \"link\"],\n                        regex: /((?:https?:\\/\\/|ftp:\\/\\/|file:\\/\\/|mailto:|callto:)[^\\s\\[]+)(\\[.*?\\])/\n                    },\n                    {token: [\"link\", \"link\"], regex: /(?:https?:\\/\\/|ftp:\\/\\/|file:\\/\\/|mailto:|callto:)[^\\s\\[]+/},\n                    {token: \"link\", regex: /\\b[\\w\\.\\/\\-]+@[\\w\\.\\/\\-]+\\b/},\n                    {include: \"macros\"},\n                    {include: \"paragraphEnd\"},\n                    {token: \"literal\", regex: /\\+{3,}/, next: \"smallPassthrough\"},\n                    {\n                        token: \"escape\",\n                        regex: /\\((?:C|TM|R)\\)|\\.{3}|->|<-|=>|<=|&#(?:\\d+|x[a-fA-F\\d]+);|(?: |^)--(?=\\s+\\S)/\n                    },\n                    {token: \"escape\", regex: /\\\\[_*'`+#]|\\\\{2}[_*'`+#]{2}/},\n                    {token: \"keyword\", regex: /\\s\\+$/},\n                    // any word\n                    {token: \"text\", regex: identifierRe},\n                    {\n                        token: [\"keyword\", \"string\", \"keyword\"],\n                        regex: /(<<[\\w\\d\\-$]+,)(.*?)(>>|$)/\n                    },\n                    {token: \"keyword\", regex: /<<[\\w\\d\\-$]+,?|>>/},\n                    {token: \"constant.character\", regex: /\\({2,3}.*?\\){2,3}/},\n                    // List of callouts\n                    {token: \"support.function.list.callout\", regex: /^(?:<\\d+>|\\d+>|>) /, next: \"text\"},\n                    // Anchor\n                    {token: \"keyword\", regex: /\\[\\[.+?\\]\\]/},\n                    // bibliography\n                    {token: \"support\", regex: /^\\[{3}[\\w\\d =\\-]+\\]{3}/},\n\n                    {include: \"quotes\"},\n                    // text block end\n                    {token: \"empty\", regex: /^\\s*$/, next: \"start\"}\n                ],\n\n                \"listText\": [\n                    {include: \"listStart\"},\n                    {include: \"text\"}\n                ],\n\n                \"indentedBlock\": [\n                    {token: \"literal\", regex: /^[\\s\\w].+$/, next: \"indentedBlock\"},\n                    {token: \"literal\", regex: \"\", next: \"start\"}\n                ],\n\n                \"listingBlock\": [\n                    {token: \"literal\", regex: /^\\.{4,}\\s*$/, next: \"dissallowDelimitedBlock\"},\n                    {token: \"constant.numeric\", regex: '<\\\\d+>'},\n                    {token: \"literal\", regex: '[^<]+'},\n                    {token: \"literal\", regex: '<'}\n                ],\n                \"literalBlock\": [\n                    {token: \"literal\", regex: /^-{4,}\\s*$/, next: \"dissallowDelimitedBlock\"},\n                    {token: \"constant.numeric\", regex: '<\\\\d+>'},\n                    {token: \"literal\", regex: '[^<]+'},\n                    {token: \"literal\", regex: '<'}\n                ],\n                \"passthroughBlock\": [\n                    {token: \"literal\", regex: /^\\+{4,}\\s*$/, next: \"dissallowDelimitedBlock\"},\n                    {token: \"literal\", regex: identifierRe + \"|\\\\d+\"},\n                    {include: \"macros\"},\n                    {token: \"literal\", regex: \".\"}\n                ],\n\n                \"smallPassthrough\": [\n                    {token: \"literal\", regex: /[+]{3,}/, next: \"dissallowDelimitedBlock\"},\n                    {token: \"literal\", regex: /^\\s*$/, next: \"dissallowDelimitedBlock\"},\n                    {token: \"literal\", regex: identifierRe + \"|\\\\d+\"},\n                    {include: \"macros\"}\n                ],\n\n                \"commentBlock\": [\n                    {token: \"doc.comment\", regex: /^\\/{4,}\\s*$/, next: \"dissallowDelimitedBlock\"},\n                    {token: \"doc.comment\", regex: '^.*$'}\n                ],\n                \"tableBlock\": [\n                    {token: \"tableBlock\", regex: /^\\s*\\|={3,}\\s*$/, next: \"dissallowDelimitedBlock\"},\n                    {token: \"tableBlock\", regex: /^\\s*!={3,}\\s*$/, next: \"innerTableBlock\"},\n                    {token: \"tableBlock\", regex: /\\|/},\n                    {include: \"text\", noEscape: true}\n                ],\n                \"innerTableBlock\": [\n                    {token: \"tableBlock\", regex: /^\\s*!={3,}\\s*$/, next: \"tableBlock\"},\n                    {token: \"tableBlock\", regex: /^\\s*|={3,}\\s*$/, next: \"dissallowDelimitedBlock\"},\n                    {token: \"tableBlock\", regex: /\\!/}\n                ],\n                \"macros\": [\n                    {token: \"macro\", regex: /{[\\w\\-$]+}/},\n                    {\n                        token: [\"text\", \"string\", \"text\", \"constant.character\", \"text\"],\n                        regex: /({)([\\w\\-$]+)(:)?(.+)?(})/\n                    },\n                    {\n                        token: [\"text\", \"markup.list.macro\", \"keyword\", \"string\"],\n                        regex: /(\\w+)(footnote(?:ref)?::?)([^\\s\\[]+)?(\\[.*?\\])?/\n                    },\n                    {\n                        token: [\"markup.list.macro\", \"keyword\", \"string\"],\n                        regex: /([a-zA-Z\\-][\\w\\.\\/\\-]*::?)([^\\s\\[]+)(\\[.*?\\])?/\n                    },\n                    {token: [\"markup.list.macro\", \"keyword\"], regex: /([a-zA-Z\\-][\\w\\.\\/\\-]+::?)(\\[.*?\\])/},\n                    {token: \"keyword\", regex: /^:.+?:(?= |$)/}\n                ],\n\n                \"quotes\": [\n                    {token: \"string.italic\", regex: /__[^_\\s].*?__/},\n                    {token: \"string.italic\", regex: quoteRule(\"_\")},\n\n                    {token: \"keyword.bold\", regex: /\\*\\*[^*\\s].*?\\*\\*/},\n                    {token: \"keyword.bold\", regex: quoteRule(\"\\\\*\")},\n\n                    {token: \"literal\", regex: /\\+\\+[^+\\s].*?\\+\\+/},\n                    {token: \"literal\", regex: quoteRule(\"\\\\+\")},\n\n                    {token: \"literal\", regex: /\\$\\$.+?\\$\\$/},\n                    {token: \"literal\", regex: quoteRule(\"\\\\$\")},\n\n                    {token: \"literal\", regex: /``[^`\\s].*?``/},\n                    {token: \"literal\", regex: quoteRule(\"`\")},\n\n                    {token: \"keyword\", regex: /\\^[^\\^].*?\\^/},\n                    {token: \"keyword\", regex: quoteRule(\"\\\\^\")},\n                    {token: \"keyword\", regex: /~[^~].*?~/},\n                    {token: \"keyword\", regex: quoteRule(\"~\")},\n\n                    {token: \"keyword\", regex: /##?/},\n                    {token: \"keyword\", regex: /(?:\\B|^)``|\\b''/}\n                ]\n\n            };\n\n            function quoteRule(ch) {\n                var prefix = /\\w/.test(ch) ? \"\\\\b\" : \"(?:\\\\B|^)\";\n                return prefix + ch + \"[^\" + ch + \"].*?\" + ch + \"(?![\\\\w*])\";\n            }\n\n            //addQuoteBlock(\"text\")\n\n            var tokenMap = {\n                macro: \"constant.character\",\n                tableBlock: \"doc.comment\",\n                titleUnderline: \"markup.heading\",\n                singleLineTitle: \"markup.heading\",\n                pageBreak: \"string\",\n                option: \"string.regexp\",\n                otherBlock: \"markup.list\",\n                literal: \"support.function\",\n                optionalTitle: \"constant.numeric\",\n                escape: \"constant.language.escape\",\n                link: \"markup.underline.list\"\n            };\n\n            for (var state in this.$rules) {\n                var stateRules = this.$rules[state];\n                for (var i = stateRules.length; i--;) {\n                    var rule = stateRules[i];\n                    if (rule.include || typeof rule == \"string\") {\n                        var args = [i, 1].concat(this.$rules[rule.include || rule]);\n                        if (rule.noEscape) {\n                            args = args.filter(function (x) {\n                                return !x.next;\n                            });\n                        }\n                        stateRules.splice.apply(stateRules, args);\n                    } else if (rule.token in tokenMap) {\n                        rule.token = tokenMap[rule.token];\n                    }\n                }\n            }\n        };\n\n\n        // Ace's Syntax Tokenizer.\n\n        // tokenizing lines longer than this makes editor very slow\n        var MAX_TOKEN_COUNT = 1000;\n        var Tokenizer = function (rules) {\n            this.states = rules;\n\n            this.regExps = {};\n            this.matchMappings = {};\n            for (var key in this.states) {\n                var state = this.states[key];\n                var ruleRegExps = [];\n                var matchTotal = 0;\n                var mapping = this.matchMappings[key] = {defaultToken: \"text\"};\n                var flag = \"g\";\n\n                var splitterRurles = [];\n                for (var i = 0; i < state.length; i++) {\n                    var rule = state[i];\n                    if (rule.defaultToken)\n                        mapping.defaultToken = rule.defaultToken;\n                    if (rule.caseInsensitive)\n                        flag = \"gi\";\n                    if (rule.regex == null)\n                        continue;\n\n                    if (rule.regex instanceof RegExp)\n                        rule.regex = rule.regex.toString().slice(1, -1);\n\n                    // Count number of matching groups. 2 extra groups from the full match\n                    // And the catch-all on the end (used to force a match);\n                    var adjustedregex = rule.regex;\n                    var matchcount = new RegExp(\"(?:(\" + adjustedregex + \")|(.))\").exec(\"a\").length - 2;\n                    if (Array.isArray(rule.token)) {\n                        if (rule.token.length == 1 || matchcount == 1) {\n                            rule.token = rule.token[0];\n                        } else if (matchcount - 1 != rule.token.length) {\n                            throw new Error(\"number of classes and regexp groups in '\" +\n                                rule.token + \"'\\n'\" + rule.regex + \"' doesn't match\\n\"\n                                + (matchcount - 1) + \"!=\" + rule.token.length);\n                        } else {\n                            rule.tokenArray = rule.token;\n                            rule.token = null;\n                            rule.onMatch = this.$arrayTokens;\n                        }\n                    } else if (typeof rule.token == \"function\" && !rule.onMatch) {\n                        if (matchcount > 1)\n                            rule.onMatch = this.$applyToken;\n                        else\n                            rule.onMatch = rule.token;\n                    }\n\n                    if (matchcount > 1) {\n                        if (/\\\\\\d/.test(rule.regex)) {\n                            // Replace any backreferences and offset appropriately.\n                            adjustedregex = rule.regex.replace(/\\\\([0-9]+)/g, function (match, digit) {\n                                return \"\\\\\" + (parseInt(digit, 10) + matchTotal + 1);\n                            });\n                        } else {\n                            matchcount = 1;\n                            adjustedregex = this.removeCapturingGroups(rule.regex);\n                        }\n                        if (!rule.splitRegex && typeof rule.token != \"string\")\n                            splitterRurles.push(rule); // flag will be known only at the very end\n                    }\n\n                    mapping[matchTotal] = i;\n                    matchTotal += matchcount;\n\n                    ruleRegExps.push(adjustedregex);\n\n                    // makes property access faster\n                    if (!rule.onMatch)\n                        rule.onMatch = null;\n                }\n\n                splitterRurles.forEach(function (rule) {\n                    rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);\n                }, this);\n\n                this.regExps[key] = new RegExp(\"(\" + ruleRegExps.join(\")|(\") + \")|($)\", flag);\n            }\n        };\n\n        (function () {\n            this.$setMaxTokenCount = function (m) {\n                MAX_TOKEN_COUNT = m | 0;\n            };\n\n            this.$applyToken = function (str) {\n                var values = this.splitRegex.exec(str).slice(1);\n                var types = this.token.apply(this, values);\n\n                // required for compatibility with old modes\n                if (typeof types === \"string\")\n                    return [{type: types, value: str}];\n\n                var tokens = [];\n                for (var i = 0, l = types.length; i < l; i++) {\n                    if (values[i])\n                        tokens[tokens.length] = {\n                            type: types[i],\n                            value: values[i]\n                        };\n                }\n                return tokens;\n            },\n\n                this.$arrayTokens = function (str) {\n                    if (!str)\n                        return [];\n                    var values = this.splitRegex.exec(str);\n                    if (!values)\n                        return \"text\";\n                    var tokens = [];\n                    var types = this.tokenArray;\n                    for (var i = 0, l = types.length; i < l; i++) {\n                        if (values[i + 1])\n                            tokens[tokens.length] = {\n                                type: types[i],\n                                value: values[i + 1]\n                            };\n                    }\n                    return tokens;\n                };\n\n            this.removeCapturingGroups = function (src) {\n                var r = src.replace(\n                    /\\[(?:\\\\.|[^\\]])*?\\]|\\\\.|\\(\\?[:=!]|(\\()/g,\n                    function (x, y) {\n                        return y ? \"(?:\" : x;\n                    }\n                );\n                return r;\n            };\n\n            this.createSplitterRegexp = function (src, flag) {\n                if (src.indexOf(\"(?=\") != -1) {\n                    var stack = 0;\n                    var inChClass = false;\n                    var lastCapture = {};\n                    src.replace(/(\\\\.)|(\\((?:\\?[=!])?)|(\\))|([\\[\\]])/g, function (m, esc, parenOpen, parenClose, square, index) {\n                        if (inChClass) {\n                            inChClass = square != \"]\";\n                        } else if (square) {\n                            inChClass = true;\n                        } else if (parenClose) {\n                            if (stack == lastCapture.stack) {\n                                lastCapture.end = index + 1;\n                                lastCapture.stack = -1;\n                            }\n                            stack--;\n                        } else if (parenOpen) {\n                            stack++;\n                            if (parenOpen.length != 1) {\n                                lastCapture.stack = stack\n                                lastCapture.start = index;\n                            }\n                        }\n                        return m;\n                    });\n\n                    if (lastCapture.end != null && /^\\)*$/.test(src.substr(lastCapture.end)))\n                        src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);\n                }\n                return new RegExp(src, (flag || \"\").replace(\"g\", \"\"));\n            };\n\n            /**\n             * Returns an object containing two properties: `tokens`, which contains all the tokens; and `state`, the current state.\n             * @returns {Object}\n             **/\n            this.getLineTokens = function (line, startState) {\n                if (startState && typeof startState != \"string\") {\n                    var stack = startState.slice(0);\n                    startState = stack[0];\n                } else\n                    var stack = [];\n\n                var currentState = startState || \"start\";\n                var state = this.states[currentState];\n                if (!state) {\n                    currentState = \"start\";\n                    state = this.states[currentState];\n                }\n                var mapping = this.matchMappings[currentState];\n                var re = this.regExps[currentState];\n                re.lastIndex = 0;\n\n                var match, tokens = [];\n                var lastIndex = 0;\n\n                var token = {type: null, value: \"\"};\n\n                while (match = re.exec(line)) {\n                    var type = mapping.defaultToken;\n                    var rule = null;\n                    var value = match[0];\n                    var index = re.lastIndex;\n\n                    if (index - value.length > lastIndex) {\n                        var skipped = line.substring(lastIndex, index - value.length);\n                        if (token.type == type) {\n                            token.value += skipped;\n                        } else {\n                            if (token.type)\n                                tokens.push(token);\n                            token = {type: type, value: skipped};\n                        }\n                    }\n\n                    for (var i = 0; i < match.length - 2; i++) {\n                        if (match[i + 1] === undefined)\n                            continue;\n\n                        rule = state[mapping[i]];\n\n                        if (rule.onMatch)\n                            type = rule.onMatch(value, currentState, stack);\n                        else\n                            type = rule.token;\n\n                        if (rule.next) {\n                            if (typeof rule.next == \"string\")\n                                currentState = rule.next;\n                            else\n                                currentState = rule.next(currentState, stack);\n\n                            state = this.states[currentState];\n                            if (!state) {\n                                window.console && console.error && console.error(currentState, \"doesn't exist\");\n                                currentState = \"start\";\n                                state = this.states[currentState];\n                            }\n                            mapping = this.matchMappings[currentState];\n                            lastIndex = index;\n                            re = this.regExps[currentState];\n                            re.lastIndex = index;\n                        }\n                        break;\n                    }\n\n                    if (value) {\n                        if (typeof type == \"string\") {\n                            if ((!rule || rule.merge !== false) && token.type === type) {\n                                token.value += value;\n                            } else {\n                                if (token.type)\n                                    tokens.push(token);\n                                token = {type: type, value: value};\n                            }\n                        } else if (type) {\n                            if (token.type)\n                                tokens.push(token);\n                            token = {type: null, value: \"\"};\n                            for (var i = 0; i < type.length; i++)\n                                tokens.push(type[i]);\n                        }\n                    }\n\n                    if (lastIndex == line.length)\n                        break;\n\n                    lastIndex = index;\n\n                    if (tokens.length > MAX_TOKEN_COUNT) {\n                        // chrome doens't show contents of text nodes with very long text\n                        while (lastIndex < line.length) {\n                            if (token.type)\n                                tokens.push(token);\n                            token = {\n                                value: line.substring(lastIndex, lastIndex += 2000),\n                                type: \"overflow\"\n                            };\n                        }\n                        currentState = \"start\";\n                        stack = [];\n                        break;\n                    }\n                }\n\n                if (token.type)\n                    tokens.push(token);\n\n                if (stack.length > 1) {\n                    if (stack[0] !== currentState)\n                        stack.unshift(currentState);\n                }\n                return {\n                    tokens: tokens,\n                    state: stack.length ? stack : currentState\n                };\n            };\n\n        }).call(Tokenizer.prototype);\n\n        // Token conversion.\n        // See <https://github.com/ajaxorg/ace/wiki/Creating-or-Extending-an-Edit-Mode#common-tokens>\n        // This is not an exact match nor the best match that can be made.\n        var tokenFromAceToken = {\n            empty: null,\n            text: null,\n\n            // Keyword\n            keyword: 'keyword',\n            control: 'keyword',\n            operator: 'operator',\n\n            // Constants\n            constant: 'atom',\n            numeric: 'number',\n            character: 'atom',\n            escape: 'atom',\n\n            // Variables\n            variable: 'variable',\n            parameter: 'variable-3',\n            language: 'variable-2',  // Python's `self` uses that.\n\n            // Comments\n            comment: 'comment',\n            line: 'comment',\n            'double-slash': 'comment',\n            'double-dash': 'comment',\n            'number-sign': 'comment',\n            percentage: 'comment',\n            block: 'comment',\n            doc: 'comment',\n\n            // String\n            string: 'string',\n            quoted: 'string',\n            single: 'string',\n            double: 'string',\n            triple: 'string',\n            unquoted: 'string',\n            interpolated: 'string',\n            regexp: 'string-2',\n\n            meta: 'keyword',\n            literal: 'qualifier',\n            support: 'builtin',\n\n            // Markup\n            markup: 'tag',\n            underline: 'link',\n            link: 'link',\n            strong: 'strong',\n            heading: 'header',\n            em: 'em',\n            list: 'variable-2',\n            numbered: 'variable-2',\n            unnumbered: 'variable-2',\n            quote: 'quote',\n            raw: 'variable-2',  // Markdown's raw block uses that.\n\n            // Invalid\n            invalid: 'error',\n            illegal: 'invalidchar',\n            deprecated: 'error'\n        };\n\n        // Takes a list of Ace tokens, returns a (string) CodeMirror token.\n        var cmTokenFromAceTokens = function (tokens) {\n            var token = null;\n            for (var i = 0; i < tokens.length; i++) {\n                // Find the most specific token.\n                if (tokenFromAceToken[tokens[i]] !== undefined) {\n                    token = tokenFromAceToken[tokens[i]];\n                }\n            }\n            return token;\n        };\n\n        // Consume a token from plannedTokens.\n        var consumeToken = function (stream, state) {\n            var plannedToken = state.plannedTokens.shift();\n            if (plannedToken === undefined) {\n                return null;\n            }\n            stream.match(plannedToken.value);\n            var tokens = plannedToken.type.split('.');\n            return cmTokenFromAceTokens(tokens);\n        };\n\n        var matchToken = function (stream, state) {\n            // Anormal start: we already have planned tokens to consume.\n            if (state.plannedTokens.length > 0) {\n                return consumeToken(stream, state);\n            }\n\n            // Normal start.\n            var currentState = state.current;\n            var currentLine = stream.match(/.*$/, false)[0];\n            var tokenized = tokenizer.getLineTokens(currentLine, currentState);\n            // We got a {tokens, state} object.\n            // Each token is a {value, type} object.\n            state.plannedTokens = tokenized.tokens;\n            state.current = tokenized.state;\n\n            // Consume a token.\n            return consumeToken(stream, state);\n        }\n\n        // Initialize all state.\n        var aceHighlightRules = new HighlightRules();\n        var tokenizer = new Tokenizer(aceHighlightRules.$rules);\n\n        return {\n            startState: function () {\n                return {\n                    current: 'start',\n                    // List of {value, type}, with type being an Ace token string.\n                    plannedTokens: []\n                };\n            },\n            blankLine: function (state) {\n                matchToken('', state);\n            },\n            token: matchToken\n        };\n    });\n\n    CodeMirror.defineMIME(\"text/x-asciidoc\", \"asciidoc\");\n}\n\nexport function initCodemirrorConfig(CodeMirror) {\n    if (typeof CodeMirror === 'undefined' || _.isUndefined(CodeMirror)) return;\n    codeMirrorAsciidocConfig(CodeMirror);\n    defineCodeMirrorMimes(CodeMirror);\n    defineCodeMirrorLinkOverlay(CodeMirror);\n    defineCodeMirrorAqlMode(CodeMirror);\n}\n","<template>\n\n    <div>\n        <div :class=\"{'codemirror-with-clip-copy' : enableCopyToClipboard}\">\n            <jf-clip-copy v-if=\"enableCopyToClipboard && formattedModel && !clipboardCopyModel\" :text-to-copy=\"formattedModel\" class=\"code-mirror-copy pull-right\" :class=\"{'scrollbar-margin':codeMirrorIsWithScroll()}\" :object-name=\"clipboardCopyEntityName || 'text'\">\n            </jf-clip-copy>\n            <jf-clip-copy v-if=\"enableCopyToClipboard && clipboardCopyModel\" :text-to-copy=\"clipboardCopyModel\" class=\"code-mirror-copy pull-right\" :class=\"{'scrollbar-margin':codeMirrorIsWithScroll()}\" :object-name=\"clipboardCopyEntityName || 'text'\">\n            </jf-clip-copy>\n            <codemirror v-model=\"formattedModel\"\n                        :options=\"editorOptions\"\n                        @ready=\"codeMirrorLoaded\"></codemirror>\n        </div>\n    </div>\n\n</template>\n\n<script>\n    import {VueFactory} from \"../../services/VueFactory\";\n    import { codemirror } from 'vue-codemirror'\n    import 'codemirror/lib/codemirror.css';\n    import 'codemirror/mode/javascript/javascript.js';\n    import 'codemirror/mode/xml/xml.js';\n    import 'codemirror/mode/markdown/markdown.js';\n    import 'codemirror/mode/gfm/gfm.js';\n    import 'codemirror/addon/mode/overlay.js';\n    import 'codemirror/addon/edit/matchbrackets.js';\n    import 'codemirror/addon/selection/mark-selection.js';\n    import 'codemirror/addon/search/searchcursor.js';\n    import 'codemirror/addon/dialog/dialog.js';\n    import 'codemirror/addon/dialog/dialog.css';\n    import 'codemirror/addon/search/search.js';\n    import CodeMirror from 'codemirror';\n    import { initCodemirrorConfig } from './config.js';\n\n    window.CodeMirror = CodeMirror;\n\n    export default {\n        name: 'jf-code-mirror',\n        props: [\n            'mimeType',\n            'mode',\n            'value',\n            'allowEdit',\n            'height',\n            'apiAccess',\n            'autofocus',\n            'matchBrackets',\n            'autoFormat',\n            'autoIndent',\n            'enableCopyToClipboard',\n            'clipboardCopyModel',\n            'clipboardCopyEntityName'\n        ],\n        'jf@inject': [\n            '$scope',\n            '$element',\n            '$timeout',\n            'JFrogUIUtils'\n        ],\n        components: {\n            codemirror\n        },\n        data() {\n            return {\n                formattedModel: null,\n                editorOptions: null\n            };\n        },\n        created() {\n            initCodemirrorConfig(CodeMirror);\n            this.defineExtensions();\n        },\n        mounted() {\n            this._formatModel();\n\n            this.editorOptions = {\n                lineNumbers: true,\n                readOnly: !this.allowEdit,\n                // Don't use nocursor - it disables search\n                lineWrapping: true,\n                mode: this.mode || 'links',\n                viewportMargin: 65,\n                autofocus: this.autofocus === 'true',\n                mimeType: this.mimeType,\n                matchBrackets: this.matchBrackets,\n//                onLoad: this.codeMirrorLoaded.bind(this)\n            };\n            // Hide cursor in readonly mode\n            if (!this.allowEdit) {\n                this.$set(this.editorOptions, 'cursorBlinkRate', -1);\n            }\n        },\n        ng1_legacy: { 'controllerAs': 'jfCodeMirror' },\n        methods: {\n            codeMirrorLoaded(_editor) {\n                const { Vue } = VueFactory.getInstance();\n                Vue.nextTick(() => {\n                    this.cmApi = _editor;\n                    if (this.height) {\n                        let codeMirrorElement = $(this.$element).find('.CodeMirror');\n                        if (this.height === 'flexible') {\n                            codeMirrorElement.css('top', 0);\n                            codeMirrorElement.css('bottom', 0);\n                            codeMirrorElement.css('left', 0);\n                            codeMirrorElement.css('right', 0);\n                            codeMirrorElement.css('position', 'absolute');\n                        } else {\n                            codeMirrorElement.css('height', this.height);\n                        }\n                    }\n                    $(_editor.display.wrapper).on('click', '.cm-link', e => {\n                        let url = $(this).text();\n                        if (url) {\n                            window.open(url, '_blank', 'noopener noreferrer');\n                        }\n                    });\n                    this.$scope.$on('$destroy', () => {\n                        this.$destroyed = true;\n                        $(_editor.display.wrapper).off('click');\n                    });\n                    if (this.apiAccess) {\n                        this.$set(this.apiAccess, 'api', this.cmApi);\n                        if (this.apiAccess.onLoad) {\n                            this.apiAccess.onLoad();\n                        }\n                    }\n                })\n            },\n            autoFormatText(indent) {\n                let last = this.cmApi.lineCount();\n                let start = {\n                        line: 0,\n                        ch: 0\n                    }, end = { line: last };\n                if (indent) {\n                    this.cmApi.autoIndentRange(start, end);\n                } else {\n                    this.cmApi.autoFormatRange(start, end);\n                }\n                this.cmApi.setCursor(start);\n            },\n            _isJSON(str) {\n                try {\n                    JSON.parse(str);\n                } catch (e) {\n                    return false;\n                }\n                return true;\n            },\n            _formatModel() {\n                let format = content => {\n                    if (this.autoFormat && (this.mode === 'javascript' || this.mode === 'htmlmixed')) {\n                        this.$timeout(() => {\n                            if (this.cmApi && this.cmApi.getValue().length > 0) {\n                                this.autoFormatText();\n                                this.formattedModel = this.cmApi.getValue();\n                                this.cmApi.refresh();\n                            }\n                        });\n                    }\n                    if (this._isJSON(content)) {\n                        this.formattedModel = require('js-beautify').js_beautify(content);\n                    } else {\n                        this.formattedModel = content;\n                    }\n                    this.expectChange();\n                    this.refreshUntilVisible();\n                };\n\n                if (!this.allowEdit) {\n                    format(this.value);\n                    this.$scope.$watch('jfCodeMirror.value', v => {\n                        format(v);\n                    });\n                } else {\n                    this.formattedModel = this.value;\n                    this.$scope.$watch('jfCodeMirror.value', v => {\n                        if (this.formattedModel !== this.value) {\n                            this.formattedModel = this.value;\n                            this.expectChange();\n                            this.refreshUntilVisible();\n                        }\n                    });\n                    this.$scope.$watch('jfCodeMirror.formattedModel', v => {\n                        this.$emit('input', v);\n                    });\n                    this.expectChange();\n                    this.refreshUntilVisible();\n                }\n            },\n            refreshUntilVisible() {\n                if (this.cmApi)\n                    this.cmApi.refresh();\n                if (this.allowEdit)\n                    return;\n                this.$timeout(() => {\n                    let cmText = $(this.$element).find('.CodeMirror-code').find('pre').text().replace(/\\u200B/g, '');\n                    if (this.expectingChange && cmText === this.lastVal) {\n                        if (this.cmApi) {\n                            this.cmApi.refresh();\n                        }\n                        if (!this.$destroyed)\n                            this.refreshUntilVisible();\n                    } else if (this.expectingChange) {\n                        this.expectingChange = false;\n                        delete this.lastVal;\n                    }\n                }, 100);\n            },\n            expectChange() {\n                let cmText = $(this.$element).find('.CodeMirror-code').find('pre').text().replace(/\\u200B/g, '');\n                this.expectingChange = true;\n                this.lastVal = cmText;\n            },\n            defineExtensions() {\n                CodeMirror.defineExtension('autoFormatRange', (from, to) => {\n                    let cm = this.cmApi;\n                    let outer = cm.getMode(), text = cm.getRange(from, to).split('\\n');\n                    let state = CodeMirror.copyState(outer, cm.getTokenAt(from).state);\n                    let tabSize = cm.getOption('tabSize');\n\n                    let out = '', lines = 0, atSol = from.ch == 0;\n                    let newline = () => {\n                        out += '\\n';\n                        atSol = true;\n                        ++lines;\n                    };\n\n                    for (let i = 0; i < text.length; ++i) {\n                        let stream = new CodeMirror.StringStream(text[i], tabSize);\n                        while (!stream.eol()) {\n                            let inner = CodeMirror.innerMode(outer, state);\n                            let style = outer.token(stream, state), cur = stream.current();\n                            stream.start = stream.pos;\n                            if (!atSol || /\\S/.test(cur)) {\n                                out += cur;\n                                atSol = false;\n                            }\n                            if (!atSol && inner.mode.newlineAfterToken && inner.mode.newlineAfterToken(style, cur, stream.string.slice(stream.pos) || text[i + 1] || '', inner.state))\n                                newline();\n                        }\n                        if (!stream.pos && outer.blankLine)\n                            outer.blankLine(state);\n                        if (!atSol)\n                            newline();\n                    }\n\n                    cm.operation(() => {\n                        cm.replaceRange(out, from, to);\n                        for (let cur = from.line + 1, end = from.line + lines; cur <= end; ++cur)\n                            cm.indentLine(cur, 'smart');\n                    });\n                });\n\n                // Applies automatic mode-aware indentation to the specified range\n                CodeMirror.defineExtension('autoIndentRange', (from, to) => {\n                    let cmInstance = this.cmApi;\n                    this.cmApi.operation(() => {\n                        for (let i = from.line; i <= to.line; i++) {\n                            cmInstance.indentLine(i, 'smart');\n                        }\n                    });\n                });\n            },\n            codeMirrorIsWithScroll() {\n                if (!this.$element) return false;\n                let codemirrorScrollBar = this.$element.find('.CodeMirror .CodeMirror-vscrollbar:not(:hidden)');\n                return codemirrorScrollBar && codemirrorScrollBar.length > 0;\n            }\n        }\n    };\n\n</script>\n\n<style scoped lang=\"less\">\n\n    @import \"../../assets/stylesheets/variables.less\";\n\n    .CodeMirror {\n        height: auto;\n        border: 1px solid #eee;\n        padding: 15px;\n\n        .CodeMirror-code {\n            div:nth-child(even) {\n                &, .CodeMirror-gutter-wrapper {\n                    background-color: @grayGridRow;\n                }\n            }\n        }\n\n        .CodeMirror-gutters {\n            border-right: 0 none;\n            background-color: transparent;\n        }\n\n        pre, .CodeMirror-linenumber {\n            font-size: 12px;\n            line-height: 20px;\n        }\n\n        .CodeMirror-linenumber {\n            text-align: left;\n        }\n    }\n\n    .codemirror-with-clip-copy,\n    .codemirror-wrapper {\n        position:relative;\n    }\n    .code-mirror-copy{\n     position: absolute;\n        right: 20px;\n        top:5px;\n        z-index: 1;\n    }\n\n\n</style>\n","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./index.vue?vue&type=template&id=5b7e1fcc&scoped=true&\"\nimport script from \"./index.vue?vue&type=script&lang=js&\"\nexport * from \"./index.vue?vue&type=script&lang=js&\"\nimport style0 from \"./index.vue?vue&type=style&index=0&id=5b7e1fcc&scoped=true&lang=less&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"5b7e1fcc\",\n  null\n  \n)\n\nexport default component.exports","export * from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--10-oneOf-1-0!../../../node_modules/css-loader/index.js??ref--10-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--10-oneOf-1-2!../../../node_modules/less-loader/dist/cjs.js??ref--10-oneOf-1-3!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=style&index=0&id=5b7e1fcc&scoped=true&lang=less&\""],"sourceRoot":""}