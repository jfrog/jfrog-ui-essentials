{"version":3,"sources":["webpack://jfrog-ui-essentials/./node_modules/bootstrap-vue/es/components/carousel/carousel.js"],"names":["exports","__esModule","default","_vue","_interopRequireDefault","__webpack_require__","_keyCodes","_noop","_observeDom","_config","_dom","_env","_inspect","_id","obj","NAME","DIRECTION","next","dirClass","overlayClass","prev","TRANS_DURATION","TOUCH_EVENT_COMPAT_WAIT","SWIPE_THRESHOLD","PointerType","TOUCH","PEN","TransitionEndEvents","WebkitTransition","MozTransition","OTransition","transition","EventOptions","passive","capture","getTransitionEndEvent","el","name","isUndefined","style","_default2","extend","mixins","provide","bvCarousel","this","model","prop","event","props","labelPrev","type","String","getComponentConfig","labelNext","labelGotoSlide","labelIndicators","interval","Number","indicators","Boolean","controls","noAnimation","fade","noTouch","noHoverPause","imgWidth","imgHeight","background","value","data","index","isSliding","transitionEndEvent","slides","direction","isPaused","parseInt","touchStartX","touchDeltaX","watch","newVal","oldVal","setSlide","pause","start","$emit","to","from","doSlide","created","_intervalId","_animationTimeout","_touchTimeout","mounted","$el","updateSlides","$refs","inner","bind","subtree","childList","attributes","attributeFilter","beforeDestroy","clearTimeout","clearInterval","methods","slide","_this","arguments","length","undefined","isBrowser","document","visibilityState","hidden","len","$once","Math","floor","evt","setInterval","max","restart","contains","activeElement","_this2","isCycling","calcDirection","currentSlide","nextSlide","addClass","removeClass","$nextTick","reflow","called","onceTransEnd","events","split","forEach","eventOff","setAttr","eventOn","setTimeout","selectAll","numSlides","min","idx","n","curIndex","nextIndex","handleClick","fn","keyCode","SPACE","ENTER","preventDefault","stopPropagation","handleSwipe","absDeltaX","abs","touchStart","hasPointerEventSupport","pointerType","toUpperCase","clientX","touches","touchMove","touchEnd","render","h","_this3","ref","class","attrs","id","safeId","role","$slots","href","aria-controls","on","click","keydown","aria-hidden","directives","rawName","expression","aria-label","aria-owns","map","key","concat","active","tabindex","aria-current","aria-describedby","mouseenter","mouseleave","focusin","focusout","test","target","tagName","LEFT","RIGHT","hasTouchSupport","staticClass","carousel-fade","pointer-event","aria-busy"],"mappings":"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","file":"jfrog-ui-essentials.umd.min.vendors-chunks~b8b45e12.js","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _vue = _interopRequireDefault(require(\"../../utils/vue\"));\n\nvar _keyCodes = _interopRequireDefault(require(\"../../utils/key-codes\"));\n\nvar _noop = _interopRequireDefault(require(\"../../utils/noop\"));\n\nvar _observeDom = _interopRequireDefault(require(\"../../utils/observe-dom\"));\n\nvar _config = require(\"../../utils/config\");\n\nvar _dom = require(\"../../utils/dom\");\n\nvar _env = require(\"../../utils/env\");\n\nvar _inspect = require(\"../../utils/inspect\");\n\nvar _id = _interopRequireDefault(require(\"../../mixins/id\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar NAME = 'BCarousel'; // Slide directional classes\n\nvar DIRECTION = {\n  next: {\n    dirClass: 'carousel-item-left',\n    overlayClass: 'carousel-item-next'\n  },\n  prev: {\n    dirClass: 'carousel-item-right',\n    overlayClass: 'carousel-item-prev'\n  } // Fallback Transition duration (with a little buffer) in ms\n\n};\nvar TRANS_DURATION = 600 + 50; // Time for mouse compat events to fire after touch\n\nvar TOUCH_EVENT_COMPAT_WAIT = 500; // Number of pixels to consider touch move a swipe\n\nvar SWIPE_THRESHOLD = 40; // PointerEvent pointer types\n\nvar PointerType = {\n  TOUCH: 'touch',\n  PEN: 'pen' // Transition Event names\n\n};\nvar TransitionEndEvents = {\n  WebkitTransition: 'webkitTransitionEnd',\n  MozTransition: 'transitionend',\n  OTransition: 'otransitionend oTransitionEnd',\n  transition: 'transitionend'\n};\nvar EventOptions = {\n  passive: true,\n  capture: false // Return the browser specific transitionEnd event name\n\n};\n\nfunction getTransitionEndEvent(el) {\n  for (var name in TransitionEndEvents) {\n    if (!(0, _inspect.isUndefined)(el.style[name])) {\n      return TransitionEndEvents[name];\n    }\n  } // fallback\n\n  /* istanbul ignore next */\n\n\n  return null;\n} // @vue/component\n\n\nvar _default2 = _vue.default.extend({\n  name: 'BCarousel',\n  mixins: [_id.default],\n  provide: function provide() {\n    return {\n      bvCarousel: this\n    };\n  },\n  model: {\n    prop: 'value',\n    event: 'input'\n  },\n  props: {\n    labelPrev: {\n      type: String,\n      default: function _default() {\n        return String((0, _config.getComponentConfig)(NAME, 'labelPrev'));\n      }\n    },\n    labelNext: {\n      type: String,\n      default: function _default() {\n        return String((0, _config.getComponentConfig)(NAME, 'labelNext'));\n      }\n    },\n    labelGotoSlide: {\n      type: String,\n      default: function _default() {\n        return String((0, _config.getComponentConfig)(NAME, 'labelGotoSlide'));\n      }\n    },\n    labelIndicators: {\n      type: String,\n      default: function _default() {\n        return String((0, _config.getComponentConfig)(NAME, 'labelIndicators'));\n      }\n    },\n    interval: {\n      type: Number,\n      default: 5000\n    },\n    indicators: {\n      type: Boolean,\n      default: false\n    },\n    controls: {\n      type: Boolean,\n      default: false\n    },\n    noAnimation: {\n      // Disable slide/fade animation\n      type: Boolean,\n      default: false\n    },\n    fade: {\n      // Enable cross-fade animation instead of slide animation\n      type: Boolean,\n      default: false\n    },\n    noTouch: {\n      // Sniffed by carousel-slide\n      type: Boolean,\n      default: false\n    },\n    noHoverPause: {\n      // Disable pause on hover\n      type: Boolean,\n      default: false\n    },\n    imgWidth: {\n      // Sniffed by carousel-slide\n      type: [Number, String] // default: undefined\n\n    },\n    imgHeight: {\n      // Sniffed by carousel-slide\n      type: [Number, String] // default: undefined\n\n    },\n    background: {\n      type: String // default: undefined\n\n    },\n    value: {\n      type: Number,\n      default: 0\n    }\n  },\n  data: function data() {\n    return {\n      index: this.value || 0,\n      isSliding: false,\n      transitionEndEvent: null,\n      slides: [],\n      direction: null,\n      isPaused: !(parseInt(this.interval, 10) > 0),\n      // Touch event handling values\n      touchStartX: 0,\n      touchDeltaX: 0\n    };\n  },\n  watch: {\n    value: function value(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.setSlide(newVal);\n      }\n    },\n    interval: function interval(newVal, oldVal) {\n      if (newVal === oldVal) {\n        /* istanbul ignore next */\n        return;\n      }\n\n      if (!newVal) {\n        // Pausing slide show\n        this.pause(false);\n      } else {\n        // Restarting or Changing interval\n        this.pause(true);\n        this.start(false);\n      }\n    },\n    isPaused: function isPaused(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.$emit(newVal ? 'paused' : 'unpaused');\n      }\n    },\n    index: function index(to, from) {\n      if (to === from || this.isSliding) {\n        /* istanbul ignore next */\n        return;\n      }\n\n      this.doSlide(to, from);\n    }\n  },\n  created: function created() {\n    // Create private non-reactive props\n    this._intervalId = null;\n    this._animationTimeout = null;\n    this._touchTimeout = null; // Set initial paused state\n\n    this.isPaused = !(parseInt(this.interval, 10) > 0);\n  },\n  mounted: function mounted() {\n    // Cache current browser transitionend event name\n    this.transitionEndEvent = getTransitionEndEvent(this.$el) || null; // Get all slides\n\n    this.updateSlides(); // Observe child changes so we can update slide list\n\n    (0, _observeDom.default)(this.$refs.inner, this.updateSlides.bind(this), {\n      subtree: false,\n      childList: true,\n      attributes: true,\n      attributeFilter: ['id']\n    });\n  },\n  beforeDestroy: function beforeDestroy() {\n    clearTimeout(this._animationTimeout);\n    clearTimeout(this._touchTimeout);\n    clearInterval(this._intervalId);\n    this._intervalId = null;\n    this._animationTimeout = null;\n    this._touchTimeout = null;\n  },\n  methods: {\n    // Set slide\n    setSlide: function setSlide(slide) {\n      var _this = this;\n\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      // Don't animate when page is not visible\n\n      /* istanbul ignore if: difficult to test */\n      if (_env.isBrowser && document.visibilityState && document.hidden) {\n        return;\n      }\n\n      var len = this.slides.length; // Don't do anything if nothing to slide to\n\n      if (len === 0) {\n        return;\n      } // Don't change slide while transitioning, wait until transition is done\n\n\n      if (this.isSliding) {\n        // Schedule slide after sliding complete\n        this.$once('sliding-end', function () {\n          return _this.setSlide(slide, direction);\n        });\n        return;\n      }\n\n      this.direction = direction; // Make sure we have an integer (you never know!)\n\n      slide = Math.floor(slide); // Set new slide index. Wrap around if necessary\n\n      this.index = slide >= len ? 0 : slide >= 0 ? slide : len - 1;\n    },\n    // Previous slide\n    prev: function prev() {\n      this.setSlide(this.index - 1, 'prev');\n    },\n    // Next slide\n    next: function next() {\n      this.setSlide(this.index + 1, 'next');\n    },\n    // Pause auto rotation\n    pause: function pause(evt) {\n      if (!evt) {\n        this.isPaused = true;\n      }\n\n      if (this._intervalId) {\n        clearInterval(this._intervalId);\n        this._intervalId = null;\n      }\n    },\n    // Start auto rotate slides\n    start: function start(evt) {\n      if (!evt) {\n        this.isPaused = false;\n      }\n      /* istanbul ignore next: most likely will never happen, but just in case */\n\n\n      if (this._intervalId) {\n        clearInterval(this._intervalId);\n        this._intervalId = null;\n      } // Don't start if no interval, or less than 2 slides\n\n\n      if (this.interval && this.slides.length > 1) {\n        this._intervalId = setInterval(this.next, Math.max(1000, this.interval));\n      }\n    },\n    // Restart auto rotate slides when focus/hover leaves the carousel\n    restart: function restart(evt)\n    /* istanbul ignore next: difficult to test */\n    {\n      if (!this.$el.contains(document.activeElement)) {\n        this.start();\n      }\n    },\n    doSlide: function doSlide(to, from) {\n      var _this2 = this;\n\n      var isCycling = Boolean(this.interval); // Determine sliding direction\n\n      var direction = this.calcDirection(this.direction, from, to);\n      var overlayClass = direction.overlayClass;\n      var dirClass = direction.dirClass; // Determine current and next slides\n\n      var currentSlide = this.slides[from];\n      var nextSlide = this.slides[to]; // Don't do anything if there aren't any slides to slide to\n\n      if (!currentSlide || !nextSlide) {\n        /* istanbul ignore next */\n        return;\n      } // Start animating\n\n\n      this.isSliding = true;\n\n      if (isCycling) {\n        this.pause(false);\n      }\n\n      this.$emit('sliding-start', to); // Update v-model\n\n      this.$emit('input', this.index);\n\n      if (this.noAnimation) {\n        (0, _dom.addClass)(nextSlide, 'active');\n        (0, _dom.removeClass)(currentSlide, 'active');\n        this.isSliding = false; // Notify ourselves that we're done sliding (slid)\n\n        this.$nextTick(function () {\n          return _this2.$emit('sliding-end', to);\n        });\n      } else {\n        (0, _dom.addClass)(nextSlide, overlayClass); // Trigger a reflow of next slide\n\n        (0, _dom.reflow)(nextSlide);\n        (0, _dom.addClass)(currentSlide, dirClass);\n        (0, _dom.addClass)(nextSlide, dirClass); // Transition End handler\n\n        var called = false;\n        /* istanbul ignore next: difficult to test */\n\n        var onceTransEnd = function onceTransEnd(evt) {\n          if (called) {\n            return;\n          }\n\n          called = true;\n          /* istanbul ignore if: transition events cant be tested in JSDOM */\n\n          if (_this2.transitionEndEvent) {\n            var events = _this2.transitionEndEvent.split(/\\s+/);\n\n            events.forEach(function (evt) {\n              return (0, _dom.eventOff)(currentSlide, evt, onceTransEnd, EventOptions);\n            });\n          }\n\n          _this2._animationTimeout = null;\n          (0, _dom.removeClass)(nextSlide, dirClass);\n          (0, _dom.removeClass)(nextSlide, overlayClass);\n          (0, _dom.addClass)(nextSlide, 'active');\n          (0, _dom.removeClass)(currentSlide, 'active');\n          (0, _dom.removeClass)(currentSlide, dirClass);\n          (0, _dom.removeClass)(currentSlide, overlayClass);\n          (0, _dom.setAttr)(currentSlide, 'aria-current', 'false');\n          (0, _dom.setAttr)(nextSlide, 'aria-current', 'true');\n          (0, _dom.setAttr)(currentSlide, 'aria-hidden', 'true');\n          (0, _dom.setAttr)(nextSlide, 'aria-hidden', 'false');\n          _this2.isSliding = false;\n          _this2.direction = null; // Notify ourselves that we're done sliding (slid)\n\n          _this2.$nextTick(function () {\n            return _this2.$emit('sliding-end', to);\n          });\n        }; // Set up transitionend handler\n\n        /* istanbul ignore if: transition events cant be tested in JSDOM */\n\n\n        if (this.transitionEndEvent) {\n          var events = this.transitionEndEvent.split(/\\s+/);\n          events.forEach(function (event) {\n            return (0, _dom.eventOn)(currentSlide, event, onceTransEnd, EventOptions);\n          });\n        } // Fallback to setTimeout()\n\n\n        this._animationTimeout = setTimeout(onceTransEnd, TRANS_DURATION);\n      }\n\n      if (isCycling) {\n        this.start(false);\n      }\n    },\n    // Update slide list\n    updateSlides: function updateSlides() {\n      this.pause(true); // Get all slides as DOM elements\n\n      this.slides = (0, _dom.selectAll)('.carousel-item', this.$refs.inner);\n      var numSlides = this.slides.length; // Keep slide number in range\n\n      var index = Math.max(0, Math.min(Math.floor(this.index), numSlides - 1));\n      this.slides.forEach(function (slide, idx) {\n        var n = idx + 1;\n\n        if (idx === index) {\n          (0, _dom.addClass)(slide, 'active');\n          (0, _dom.setAttr)(slide, 'aria-current', 'true');\n        } else {\n          (0, _dom.removeClass)(slide, 'active');\n          (0, _dom.setAttr)(slide, 'aria-current', 'false');\n        }\n\n        (0, _dom.setAttr)(slide, 'aria-posinset', String(n));\n        (0, _dom.setAttr)(slide, 'aria-setsize', String(numSlides));\n      }); // Set slide as active\n\n      this.setSlide(index);\n      this.start(this.isPaused);\n    },\n    calcDirection: function calcDirection() {\n      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var curIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var nextIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      if (!direction) {\n        return nextIndex > curIndex ? DIRECTION.next : DIRECTION.prev;\n      }\n\n      return DIRECTION[direction];\n    },\n    handleClick: function handleClick(evt, fn) {\n      var keyCode = evt.keyCode;\n\n      if (evt.type === 'click' || keyCode === _keyCodes.default.SPACE || keyCode === _keyCodes.default.ENTER) {\n        evt.preventDefault();\n        evt.stopPropagation();\n        fn();\n      }\n    },\n    handleSwipe: function handleSwipe()\n    /* istanbul ignore next: JSDOM doesn't support touch events */\n    {\n      var absDeltaX = Math.abs(this.touchDeltaX);\n\n      if (absDeltaX <= SWIPE_THRESHOLD) {\n        return;\n      }\n\n      var direction = absDeltaX / this.touchDeltaX;\n\n      if (direction > 0) {\n        // Swipe left\n        this.prev();\n      } else if (direction < 0) {\n        // Swipe right\n        this.next();\n      }\n    },\n    touchStart: function touchStart(evt)\n    /* istanbul ignore next: JSDOM doesn't support touch events */\n    {\n      if (_env.hasPointerEventSupport && PointerType[evt.pointerType.toUpperCase()]) {\n        this.touchStartX = evt.clientX;\n      } else if (!_env.hasPointerEventSupport) {\n        this.touchStartX = evt.touches[0].clientX;\n      }\n    },\n    touchMove: function touchMove(evt)\n    /* istanbul ignore next: JSDOM doesn't support touch events */\n    {\n      // Ensure swiping with one touch and not pinching\n      if (evt.touches && evt.touches.length > 1) {\n        this.touchDeltaX = 0;\n      } else {\n        this.touchDeltaX = evt.touches[0].clientX - this.touchStartX;\n      }\n    },\n    touchEnd: function touchEnd(evt)\n    /* istanbul ignore next: JSDOM doesn't support touch events */\n    {\n      if (_env.hasPointerEventSupport && PointerType[evt.pointerType.toUpperCase()]) {\n        this.touchDeltaX = evt.clientX - this.touchStartX;\n      }\n\n      this.handleSwipe(); // If it's a touch-enabled device, mouseenter/leave are fired as\n      // part of the mouse compatibility events on first tap - the carousel\n      // would stop cycling until user tapped out of it;\n      // here, we listen for touchend, explicitly pause the carousel\n      // (as if it's the second time we tap on it, mouseenter compat event\n      // is NOT fired) and after a timeout (to allow for mouse compatibility\n      // events to fire) we explicitly restart cycling\n\n      this.pause(false);\n\n      if (this._touchTimeout) {\n        clearTimeout(this._touchTimeout);\n      }\n\n      this._touchTimeout = setTimeout(this.start, TOUCH_EVENT_COMPAT_WAIT + Math.max(1000, this.interval));\n    }\n  },\n  render: function render(h) {\n    var _this3 = this;\n\n    // Wrapper for slides\n    var inner = h('div', {\n      ref: 'inner',\n      class: ['carousel-inner'],\n      attrs: {\n        id: this.safeId('__BV_inner_'),\n        role: 'list'\n      }\n    }, [this.$slots.default]); // Prev and next controls\n\n    var controls = h(false);\n\n    if (this.controls) {\n      controls = [h('a', {\n        class: ['carousel-control-prev'],\n        attrs: {\n          href: '#',\n          role: 'button',\n          'aria-controls': this.safeId('__BV_inner_')\n        },\n        on: {\n          click: function click(evt) {\n            _this3.handleClick(evt, _this3.prev);\n          },\n          keydown: function keydown(evt) {\n            _this3.handleClick(evt, _this3.prev);\n          }\n        }\n      }, [h('span', {\n        class: ['carousel-control-prev-icon'],\n        attrs: {\n          'aria-hidden': 'true'\n        }\n      }), h('span', {\n        class: ['sr-only']\n      }, [this.labelPrev])]), h('a', {\n        class: ['carousel-control-next'],\n        attrs: {\n          href: '#',\n          role: 'button',\n          'aria-controls': this.safeId('__BV_inner_')\n        },\n        on: {\n          click: function click(evt) {\n            _this3.handleClick(evt, _this3.next);\n          },\n          keydown: function keydown(evt) {\n            _this3.handleClick(evt, _this3.next);\n          }\n        }\n      }, [h('span', {\n        class: ['carousel-control-next-icon'],\n        attrs: {\n          'aria-hidden': 'true'\n        }\n      }), h('span', {\n        class: ['sr-only']\n      }, [this.labelNext])])];\n    } // Indicators\n\n\n    var indicators = h('ol', {\n      class: ['carousel-indicators'],\n      directives: [{\n        name: 'show',\n        rawName: 'v-show',\n        value: this.indicators,\n        expression: 'indicators'\n      }],\n      attrs: {\n        id: this.safeId('__BV_indicators_'),\n        'aria-hidden': this.indicators ? 'false' : 'true',\n        'aria-label': this.labelIndicators,\n        'aria-owns': this.safeId('__BV_inner_')\n      }\n    }, this.slides.map(function (slide, n) {\n      return h('li', {\n        key: \"slide_\".concat(n),\n        class: {\n          active: n === _this3.index\n        },\n        attrs: {\n          role: 'button',\n          id: _this3.safeId(\"__BV_indicator_\".concat(n + 1, \"_\")),\n          tabindex: _this3.indicators ? '0' : '-1',\n          'aria-current': n === _this3.index ? 'true' : 'false',\n          'aria-label': \"\".concat(_this3.labelGotoSlide, \" \").concat(n + 1),\n          'aria-describedby': _this3.slides[n].id || null,\n          'aria-controls': _this3.safeId('__BV_inner_')\n        },\n        on: {\n          click: function click(evt) {\n            _this3.handleClick(evt, function () {\n              _this3.setSlide(n);\n            });\n          },\n          keydown: function keydown(evt) {\n            _this3.handleClick(evt, function () {\n              _this3.setSlide(n);\n            });\n          }\n        }\n      });\n    }));\n    var on = {\n      mouseenter: this.noHoverPause ? _noop.default : this.pause,\n      mouseleave: this.noHoverPause ? _noop.default : this.restart,\n      focusin: this.pause,\n      focusout: this.restart,\n      keydown: function keydown(evt) {\n        if (/input|textarea/i.test(evt.target.tagName)) {\n          /* istanbul ignore next */\n          return;\n        }\n\n        var keyCode = evt.keyCode;\n\n        if (keyCode === _keyCodes.default.LEFT || keyCode === _keyCodes.default.RIGHT) {\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          _this3[keyCode === _keyCodes.default.LEFT ? 'prev' : 'next']();\n        }\n      } // Touch support event handlers for environment\n\n    };\n\n    if (!this.noTouch && _env.hasTouchSupport) {\n      // Attach appropriate listeners (prepend event name with '&' for passive mode)\n\n      /* istanbul ignore next: JSDOM doesn't support touch events */\n      if (_env.hasPointerEventSupport) {\n        on['&pointerdown'] = this.touchStart;\n        on['&pointerup'] = this.touchEnd;\n      } else {\n        on['&touchstart'] = this.touchStart;\n        on['&touchmove'] = this.touchMove;\n        on['&touchend'] = this.touchEnd;\n      }\n    } // Return the carousel\n\n\n    return h('div', {\n      staticClass: 'carousel',\n      class: {\n        slide: !this.noAnimation,\n        'carousel-fade': !this.noAnimation && this.fade,\n        'pointer-event': !this.noTouch && _env.hasTouchSupport && _env.hasPointerEventSupport\n      },\n      style: {\n        background: this.background\n      },\n      attrs: {\n        role: 'region',\n        id: this.safeId(),\n        'aria-busy': this.isSliding ? 'true' : 'false'\n      },\n      on: on\n    }, [inner, controls, indicators]);\n  }\n});\n\nexports.default = _default2;"],"sourceRoot":""}