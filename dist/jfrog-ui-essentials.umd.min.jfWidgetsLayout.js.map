{"version":3,"sources":["webpack://jfrog-ui-essentials/./src/components/JfWidgetsLayoutComponent/index.vue","webpack://jfrog-ui-essentials/src/components/JfWidgetsLayoutComponent/index.vue","webpack://jfrog-ui-essentials/./src/components/JfWidgetsLayoutComponent/index.vue?c21f"],"names":["render","staticRenderFns","component"],"mappings":"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","file":"jfrog-ui-essentials.umd.min.jfWidgetsLayout.js","sourcesContent":["var render, staticRenderFns\nimport script from \"./index.vue?vue&type=script&lang=js&\"\nexport * from \"./index.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"1e79feea\",\n  null\n  \n)\n\nexport default component.exports","<script>\n\n    const TEMPLATE = `\n    <div>\n        <div class=\"jf-widgets-layout-container\"  :style=\"containerCss\" @mouseleave=\"onMouseLeave($event)\" @mousemove=\"onMouseMove($event)\" @mousedown=\"onMouseDown($event)\" @mouseup=\"onMouseUp($event)\">\n            <div class=\"widgets-padder\" :style=\"padderCss\">\n                <div v-for=\"rowOrColumn in transformedLayout\" class=\"widgets-row\">\n                    <div v-for=\"layoutObj in rowOrColumn\" :style=\"cssRules[layoutObj.cssId]\" class=\"widget-wrapper\" :class=\"{['widget-wrapper-' + widgets[layoutObj.widget].id.toLowerCase()]: true, 'atom': !layoutObj.subLayout}\">\n                        <div v-if=\"!layoutObj.subLayout && editMode\" class=\"edit-mode-actions\" @mousemove=\"onWidgetMouseMove($event)\">\n                            <i class=\"glyphicon glyphicon-asterisk\" v-jf-tooltip=\"'Change'\" @click=\"changeWidget(layoutObj)\"></i>\n                            <i class=\"glyphicon glyphicon-remove-circle\" v-jf-tooltip=\"'Remove'\" v-if=\"getWidgetsCount() > 1\" @click=\"removeWidget(layoutObj)\"></i>\n                            <i class=\"glyphicon glyphicon-resize-vertical\" v-jf-tooltip=\"'Vertical Split'\" @click=\"splitCell(layoutObj,'v')\"></i>\n                            <i class=\"glyphicon glyphicon-resize-horizontal\" v-jf-tooltip=\"'Horizontal Split'\" @click=\"splitCell(layoutObj,'h')\"></i>\n                        </div>\n                        <div v-if=\"!layoutObj.subLayout && editMode && layoutObj.selectWidgetMode\" class=\"select-widget-mode\" @mousemove=\"onWidgetMouseMove($event)\">\n                            <div class=\"widget-selector\">\n                                <jf-ui-select :jf-select-model=\"layoutObj.widget\" jf-select-display-func=\"getWidgetName($item)\" jf-select-placeholder=\"Select A Widget\" jf-select-change=\"onWidgetChange(layoutObj)\" :jf-select-options=\"widgetKeys\"></jf-ui-select>\n                            </div>\n                        </div>\n                        <div v-if=\"!layoutObj.subLayout && (_getRootDirective().transformedLayout.length > 1 || _getRootDirective().transformedLayout[0].length > 1) && options.expandablePanes\" :style=\"{top: top, left: left}\" class=\"expansion-corner-mask\">\n                            <div class=\"expansion-corner-fill\" @click=\"expandPane(layoutObj)\">\n                                <div class=\"icon icon-thin-arrow\" :class=\"{expanded: layoutObj.expanded}\"></div>\n                            </div>\n                        </div>\n                        <div class=\"widget-container\" @mousemove=\"onWidgetMouseMove($event)\" v-if=\"!layoutObj.subLayout\" :style=\"{overflow: widgets[layoutObj.widget].scroll ? 'auto' : 'hidden'}\">\n                            <div v-if=\"widgets[layoutObj.widget] && widgets[layoutObj.widget].showSpinner\" class=\"widget-spinner\">\n                                <div class=\"spinner-msg\">\n                                    <div class=\"icon-hourglass\"></div>\n                                </div>\n                            </div>\n                            <div v-if=\"widgets[layoutObj.widget] && widgets[layoutObj.widget].template\" v-show=\"widgets[layoutObj.widget].$compiled || (!widgets[layoutObj.widget].model && !widgets[layoutObj.widget].controller)\">\n                                <div class=\"compile-children\" v-show=\"widgets[layoutObj.widget].$compiled\" :id=\"layoutObj.widget\" v-html=\"widgets[layoutObj.widget].template\"></div>\n                            </div>\n                        </div>\n                        <div v-if=\"layoutObj.subLayout\">\n                            <jf-widgets-layout :layout=\"layoutObj.subLayout\" :widgets=\"widgets\" :options=\"subOptions\" parent-cell=\"layoutObj\"></jf-widgets-layout>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            <div id=\"home-disclaimer\" v-html=\"footerText\" v-if=\"footerText\"></div>\n        </div>\n    </div>\n    `;\n\n    import extend from 'lodash/extend';\n    import includes from 'lodash/includes';\n    import map from 'lodash/map';\n    import cloneDeep from 'lodash/cloneDeep';\n    import indexOf from 'lodash/indexOf';\n    import filter from 'lodash/filter';\n    import find from 'lodash/find';\n\n    export default {\n        template: TEMPLATE,\n        name: 'jf-widgets-layout',\n        props: [\n            'widgets',\n            'layout',\n            'options',\n            'parentCell',\n            'footerText'\n        ],\n        'jf@inject': [\n            '$scope',\n            '$rootScope',\n            '$compile',\n            '$timeout',\n            '$q',\n            '$templateRequest',\n            '$sce',\n            '$injector',\n            '$element'\n        ],\n        data() {\n            return {\n                containerCss: null,\n                padderCss: null,\n                transformedLayout: null,\n                cssRules: null,\n                editMode: null,\n                widgetKeys: null,\n                top: null,\n                left: null,\n                subOptions: null\n            };\n        },\n        created() {\n            this.ANIM_DURATION = 0.5;\n        },\n        mounted() {\n            this.setDefaultOptions();\n\n            let onChange = (newval, oldval) => {\n                if (!newval)\n                    return;\n                this.transformLayout();\n                this.updateFlatCells();\n                this.updateCss();\n                this.updateDragLines();\n                if (this.recompile) {\n                    this.recompile = false;\n                    Object.keys(this.widgets).forEach(id => delete this.widgets[id].$compiled);\n                    this.templatesLoadStarted = false;\n                    this.templatesLoaded = false;\n                    this.$timeout(() => this.compileElements());\n                } else if (!this.templatesLoadStarted || this.templatesLoaded) {\n                    Object.keys(this.widgets).forEach(id => {\n                        if (this._isWidgetInUse(id))\n                            delete this.widgets[id].$compiled;\n                    });\n                    this.loadTemplates().then(() => {\n                        this.$timeout(() => this.compileElements());\n                    });\n                }\n            };\n            this.$scope.$watch('jfWidgetsLayout.options.editMode', editMode => {\n                this.editMode = editMode === undefined ? false : editMode;\n                this.$set(this.subOptions, 'editMode', this.editMode);\n\n                if (!editMode) {\n                    this.cleanLayout();\n                    if (!this.options.isSub) {\n                        this.updateLayoutJSON();\n\n                        if (this.wasEditing) {\n                            if (this.options.onEditEnd && this.layoutJSON)\n                                this.options.onEditEnd(this.layoutJSON);\n                            this.recompile = true;\n                        }\n                    }\n                }\n                this.wasEditing = this.editMode;\n            });\n\n            this.$scope.$watch('jfWidgetsLayout.layout', onChange);\n\n            this.$scope.$watch('jfWidgetsLayout.widgets', widgets => {\n                if (widgets) {\n                    this.widgetKeys = Object.keys(widgets);\n                }\n            });\n\n            if (this.options.parent && this.parentCell) {\n                this.$set(this.parentCell, '$childLayout', this);\n            }\n\n            this.$scope.$on('$destroy', () => {\n                if (this.scopes)\n                    this.scopes.forEach(s => s.$destroy());\n            });\n        },\n        ng1_legacy: {\n            ng1compileFn(element) {\n                return recursiveDirective.compile(element);\n            },\n            'controllerAs': 'jfWidgetsLayout'\n        },\n        methods: {\n            setDefaultOptions() {\n                if (!this.options)\n                    this.options = {};\n                if (!this.options.padding)\n                    this.$set(this.options, 'padding', 10);\n                if (!this.options.minHeight)\n                    this.$set(this.options, 'minHeight', 'initial');\n                if (!this.options.backColor)\n                    this.$set(this.options, 'backColor', 'transparent');\n                if (this.options.allowResize === undefined)\n                    this.$set(this.options, 'allowResize', false);\n                if (this.options.outerPadding === undefined)\n                    this.$set(this.options, 'outerPadding', true);\n                if (this.options.editMode === undefined)\n                    this.$set(this.options, 'editMode', false);\n\n                this.subOptions = cloneDeep(this.options);\n                this.$set(this.subOptions, 'minHeight', 'initial');\n                this.$set(this.subOptions, 'isSub', true);\n                this.$set(this.subOptions, 'parent', this);\n            },\n            transformLayout() {\n\n                let _getSizeFromCell = cell => {\n                    let i1 = cell.indexOf('%');\n                    let i2 = cell.indexOf('px');\n                    if (i1 !== -1)\n                        return cell.substr(0, i1);\n                    if (i2 !== -1)\n                        return cell.substr(0, i2);\n                };\n                let _getWidgetNameFromCell = cell => {\n                    let i = cell.indexOf('@');\n                    if (i !== -1)\n                        return cell.substr(i + 1);\n                };\n                let _getSubLayoutFromCell = cell => {\n                    let i = cell.indexOf('#');\n                    if (i !== -1)\n                        return cell.substr(i + 1);\n                };\n\n                this.transformedLayout = [];\n\n                let theLayout = this.layout.main || this.layout;\n\n                if (theLayout.rows) {\n                    this.mainAxis = 'rows';\n                } else if (theLayout.columns) {\n                    this.mainAxis = 'columns';\n                } else {\n                    console.log('Layout Format Error! Must have rows or columns.');\n                    return;\n                }\n\n                theLayout[this.mainAxis].forEach(rowOrColumn => {\n                    let tRowOrColumn = [];\n                    rowOrColumn.cells.forEach(cell => {\n                        let height = this.mainAxis === 'rows' ? rowOrColumn.size : _getSizeFromCell(cell);\n                        let width = this.mainAxis === 'columns' ? rowOrColumn.size : _getSizeFromCell(cell);\n                        let subLayoutName = _getSubLayoutFromCell(cell);\n                        let tCell = {\n                            widget: _getWidgetNameFromCell(cell),\n                            subLayout: subLayoutName ? this.layout[subLayoutName] : undefined,\n                            percentWidth: parseInt(width),\n                            percentHeight: parseInt(height)\n                        };\n                        if (rowOrColumn.new) {\n                            this.$timeout(() => {\n                                this.splitCell(tCell, this.mainAxis === 'columns' ? 'v' : 'h');\n                            });\n                        }\n                        tRowOrColumn.push(tCell);\n                    });\n                    this.transformedLayout.push(tRowOrColumn);\n                });\n\n                this.normalizeSizes();\n\n            },\n            updateFlatCells() {\n                this.flatCells = [];\n                this.transformedLayout.forEach(rowOrColumn => {\n                    rowOrColumn.forEach(cell => {\n                        this.flatCells.push(cell);\n                    });\n                });\n            },\n            loadTemplates() {\n                let defer = this.$q.defer();\n\n                if (this.templatesLoaded) {\n                    defer.resolve();\n                    return defer.promise;\n                }\n\n                this.templatesLoadStarted = true;\n                let fired = 0, completed = 0;\n                this.transformedLayout.forEach(rowOrColumn => {\n                    rowOrColumn.forEach(layoutDef => {\n                        let widget = this.widgets[layoutDef.widget];\n                        if (widget) {\n                            if (widget.templateUrl && !widget.template) {\n                                fired++;\n                                this.$templateRequest(widget.templateUrl).then(template => {\n                                    if (!widget.$templateLoaded) {\n                                        widget.template = this.$sce.trustAsHtml(template);\n                                        widget.$templateLoaded = true;\n                                    }\n                                }).finally(() => {\n                                    completed++;\n                                    //                            console.log('completed ' + completed + ' out of ' + fired);\n                                    if (fired === completed) {\n                                        this.templatesLoaded = true;\n                                        defer.resolve();\n                                    }\n                                });\n                            } else if (widget.template) {\n                                if (!widget.$templateLoaded) {\n                                    widget.template = this.$sce.trustAsHtml(widget.template);\n                                    widget.$templateLoaded = true;\n                                }\n                            }\n                        }\n                    });\n                });\n\n                if (!fired)\n                    defer.resolve();\n                return defer.promise;\n            },\n            updateCss() {\n                let oldRules = cloneDeep(this.cssRules);\n                this.cssRules = {};\n\n                let currentX = 0, currentY = 0;\n                let cssRunningId = 0;\n\n                this.transformedLayout.forEach(rowOrColumn => {\n                    if (this.mainAxis === 'rows')\n                        currentX = 0;\n                    else if (this.mainAxis === 'columns')\n                        currentY = 0;\n                    let topSize = 0;\n                    rowOrColumn.forEach(layoutDef => {\n                        let widget = this.widgets[layoutDef.widget];\n                        layoutDef.cssId = cssRunningId;\n                        if (!widget) {\n                            layoutDef.widget = '$widget' + cssRunningId;\n                        }\n                        cssRunningId++;\n\n                        this.cssRules[layoutDef.cssId] = {\n                            top: currentY + '%',\n                            left: currentX + '%',\n                            bottom: 100 - (currentY + layoutDef.percentHeight) + '%',\n                            right: 100 - (currentX + layoutDef.percentWidth) + '%',\n                            padding: this.options.padding / 2 + 'px',\n                            opacity: oldRules && oldRules[layoutDef.cssId] && oldRules[layoutDef.cssId].opacity !== undefined ? oldRules[layoutDef.cssId].opacity : 1\n                        };\n\n                        if (this.mainAxis === 'rows') {\n                            currentX += layoutDef.percentWidth;\n                            if (layoutDef.percentHeight > topSize)\n                                topSize = layoutDef.percentHeight;\n                        } else if (this.mainAxis === 'columns') {\n                            currentY += layoutDef.percentHeight;\n                            if (layoutDef.percentWidth > topSize)\n                                topSize = layoutDef.percentWidth;\n                        }\n\n                    });\n                    if (this.mainAxis === 'rows')\n                        currentY += topSize;\n                    else if (this.mainAxis === 'columns')\n                        currentX += topSize;\n                });\n\n                let pad = this.options.isSub ? 0 : this.options.outerPadding ? this.options.padding / 2 : -this.options.padding / 2;\n                this.padderCss = {\n                    top: pad + 'px',\n                    left: pad + 'px',\n                    bottom: pad + 'px',\n                    right: pad + 'px'\n                };\n\n                this.containerCss = {\n                    'min-height': this.options.minHeight + 'px',\n                    'background-color': this.options.backColor,\n                    'overflow': this.options.isSub && this.editMode ? 'visible' : 'hidden'\n                };\n\n                if (this.options.parent)\n                    this.options.parent.updateCss();\n            },\n            updateDragLines() {\n                this.dragLines = [];\n                for (let key in this.cssRules) {\n                    let rules = this.cssRules[key];\n                    let top = parseFloat(rules.top);\n                    let bottom = parseFloat(rules.bottom);\n                    let left = parseFloat(rules.left);\n                    let right = parseFloat(rules.right);\n                    let cell = find(this.flatCells, { cssId: parseInt(key) });\n                    this.addLinesFromRect({\n                        x1: left,\n                        y1: top,\n                        x2: 100 - right,\n                        y2: 100 - bottom,\n                        cssRules: rules,\n                        widget: cell.widget\n                    });\n                    cell.percentWidth = 100 - right - left;\n                    cell.percentHeight = 100 - bottom - top;\n                }\n\n            },\n            compileElements() {\n                let elems = $('.compile-children');\n                if (this.scopes)\n                    this.scopes.forEach(s => s.$destroy());\n                this.scopes = [];\n                for (let i = 0; i < elems.length; i++) {\n                    let elem = $(elems[i]);\n                    let widgetId = elem.prop('id');\n                    if (this._isWidgetInUse(widgetId)) {\n                        let widget = this._getWidgetById(widgetId);\n                        let scope = this.$rootScope.$new();\n\n                        this.scopes.push(scope);\n\n                        let children = elem.children();\n\n                        if (widget.model) {\n                            extend(scope, widget.model);\n                        }\n                        if (this.options.sharedModel) {\n                            extend(scope, this.options.sharedModel);\n                        }\n                        if (!widget.controller) {\n                            widget.controller = class Ctrl {\n                            };\n                        }\n\n                        widget.controller.prototype.$widgetLayoutManager = this;\n\n                        let controllerInstance = this.$injector.instantiate(widget.controller);\n\n                        controllerInstance.$element = children[0];\n                        controllerInstance.$layoutObject = this._getLayoutByWidget(elem.prop('id'));\n                        controllerInstance.$scope = scope;\n                        controllerInstance.$widgetObject = widget;\n\n                        let controllerObject = {};\n                        controllerObject[widget.controllerAs || 'ctrl'] = controllerInstance;\n\n                        extend(scope, controllerObject);\n\n\n                        if (controllerInstance.$onInit)\n                            controllerInstance.$onInit();\n\n                        //We compile only first child, templates should have only one root element!\n                        let rootChild = $(children[0]);\n                        if (!rootChild.prop('compiled')) {\n                            this.$compile(rootChild)(scope);\n                            rootChild.prop('compiled', true);\n                        }\n\n                        this.$timeout(() => {\n                            widget.$compiled = true;\n                        });\n\n                    }\n                }\n            },\n            _getWidgetById(id) {\n                let widget = this.widgets[id];\n                return widget;\n            },\n            _getLayoutByWidget(id) {\n                let layout;\n\n                for (let i in this.transformedLayout) {\n                    let rowOrColumn = this.transformedLayout[i];\n                    layout = find(rowOrColumn, { widget: id });\n                    if (layout)\n                        break;\n                }\n\n                return layout;\n            },\n            _isWidgetInUse(widgetId) {\n                return !!find(this.flatCells, { widget: widgetId });\n            },\n            _getPrecPoint(e) {\n                let container = $(this.$element).find('.jf-widgets-layout-container');\n\n                let containerWidth = container.innerWidth();\n                let containerHeight = container.innerHeight();\n\n                let mouseX = e.pageX - container.offset().left;\n                let mouseY = e.pageY - container.offset().top;\n\n                let xprec = Math.round(mouseX / containerWidth * 100);\n                let yprec = Math.round(mouseY / containerHeight * 100);\n\n                return {\n                    x: xprec,\n                    y: yprec\n                };\n            },\n            onMouseMove(e) {\n\n                if (!this.options.allowResize && !this.editMode)\n                    return;\n\n                if (this.draggingLines) {\n                    this.onDrag(e);\n                    e.preventDefault();\n                } else {\n\n                    let container = $(this.$element).find('.jf-widgets-layout-container');\n\n                    let prec = this._getPrecPoint(e);\n                    this.closestLines = this.getClosestLines(prec.x, prec.y);\n                    if (this.closestLines.length) {\n                        let directions = map(this.closestLines, 'cssRelevantRule');\n\n                        let cursor;\n                        if (includes(directions, 'right') && includes(directions, 'left') && includes(directions, 'top') && includes(directions, 'bottom')) {\n                            cursor = 'all-scroll';\n                            this.setSubIsOnEdge(true);\n                        } else if (includes(directions, 'top') && includes(directions, 'bottom')) {\n                            cursor = 'row-resize';\n                            this.setSubIsOnEdge(true);\n                        } else if (includes(directions, 'right') && includes(directions, 'left')) {\n                            cursor = 'col-resize';\n                            this.setSubIsOnEdge(true);\n                        } else {\n                            cursor = 'default';\n                            this.setSubIsOnEdge(false);\n                        }\n                        container.css('cursor', cursor);\n                    } else {\n                        if (!this.subIsOnEdge) {\n                            container.css('cursor', 'default');\n                            this.setSubIsOnEdge(false);\n                        }\n                    }\n                }\n\n            },\n            onMouseLeave(e) {\n                if (!this.options.allowResize && !this.editMode)\n                    return;\n                this.onMouseUp();\n                this.setSubIsOnEdge(false);\n            },\n            onDrag(e) {\n\n                let perc = this._getPrecPoint(e);\n\n                let xDiff = perc.x - this.dragStartPt.x;\n                let yDiff = perc.y - this.dragStartPt.y;\n\n                let okToDrag = true;\n\n                for (let i in this.closestLines) {\n                    let line = this.closestLines[i];\n                    let origLine = this.dragStartLines[i];\n                    let top = parseFloat(origLine.cssRules.top);\n                    let bottom = parseFloat(origLine.cssRules.bottom);\n                    let left = parseFloat(origLine.cssRules.left);\n                    let right = parseFloat(origLine.cssRules.right);\n                    let originalHeight = this._getLayoutByWidget(line.widget).percentHeight;\n                    let originalWidth = this._getLayoutByWidget(line.widget).percentWidth;\n                    if (line.cssRelevantRule === 'top') {\n                        let newTop = top + yDiff;\n                        let newHeight = 100 - bottom - newTop;\n                        if (newHeight < 0.2 * originalHeight) {\n                            okToDrag = false;\n                            break;\n                        }\n                    } else if (line.cssRelevantRule === 'bottom') {\n                        let newBottom = bottom - yDiff;\n                        let newHeight = 100 - newBottom - top;\n                        if (newHeight < 0.2 * originalHeight) {\n                            okToDrag = false;\n                            break;\n                        }\n                    } else if (line.cssRelevantRule === 'left') {\n                        let newLeft = left + xDiff;\n                        let newWidth = 100 - right - newLeft;\n                        if (newWidth < 0.2 * originalWidth) {\n                            okToDrag = false;\n                            break;\n                        }\n                    } else if (line.cssRelevantRule === 'right') {\n                        let newRight = right - xDiff;\n                        let newWidth = 100 - newRight - left;\n                        if (newWidth < 0.2 * originalWidth) {\n                            okToDrag = false;\n                            break;\n                        }\n                    }\n                }\n\n                if (okToDrag) {\n                    for (let i in this.closestLines) {\n                        let line = this.closestLines[i];\n\n                        if (!this.ensureCSSRulesSync(line, e))\n                            break;\n\n                        let origLine = this.dragStartLines[i];\n                        if (line.cssRelevantRule === 'top') {\n                            let top = parseFloat(origLine.cssRules.top);\n                            line.cssRules.top = top + yDiff + '%';\n                        } else if (line.cssRelevantRule === 'bottom') {\n                            let bottom = parseFloat(origLine.cssRules.bottom);\n                            line.cssRules.bottom = bottom - yDiff + '%';\n                        } else if (line.cssRelevantRule === 'left') {\n                            let left = parseFloat(origLine.cssRules.left);\n                            line.cssRules.left = left + xDiff + '%';\n                        } else if (line.cssRelevantRule === 'right') {\n                            let right = parseFloat(origLine.cssRules.right);\n                            line.cssRules.right = right - xDiff + '%';\n                        }\n                    }\n                }\n\n            },\n            ensureCSSRulesSync(line, e) {\n\n                // Very hacky solution TODO: Find a better solution!\n\n                let found = false;\n                for (let key in this.cssRules) {\n                    if (this.cssRules[key] === line.cssRules) {\n                        found = true;\n                        break;\n                    }\n                }\n\n                if (!found) {\n                    this.onMouseUp();\n                    this.onMouseMove(e);\n                    this.onMouseDown(e);\n                    this.onMouseMove(e);\n                    return false;\n                }\n                return true;\n            },\n            onMouseDown(e) {\n\n                if (!this.options.allowResize && !this.editMode)\n                    return;\n\n                if (this.closestLines && this.closestLines.length) {\n                    this.draggingLines = true;\n                    this.dragStartPt = cloneDeep(this._getPrecPoint(e));\n                    this.dragStartLines = cloneDeep(this.closestLines);\n                    this._setTransitions(false);\n                    e.preventDefault();\n                    e.stopPropagation();\n                }\n            },\n            onMouseUp(e) {\n                if (!this.options.allowResize && !this.editMode)\n                    return;\n\n                this.updateDragLines();\n                this.closestLines = null;\n                this.draggingLines = false;\n                this.dragStartPt = null;\n                this.dragStartLines = null;\n\n                if (e)\n                    this._setTransitions(true);\n\n            },\n            onWidgetMouseMove(e) {\n                if (!this.options.allowResize && !this.editMode)\n                    return;\n                if (this.draggingLines || this.isParentDragging())\n                    return;\n                let container = $(this.$element).find('.jf-widgets-layout-container');\n                if (!this.subIsOnEdge) {\n                    container.css('cursor', 'default');\n                    this.setSubIsOnEdge(false);\n                }\n                e.stopPropagation();\n            },\n            addLinesFromRect(rect) {\n                this.dragLines.push({\n                    x1: rect.x1,\n                    y1: rect.y1,\n                    x2: rect.x2,\n                    y2: rect.y1,\n                    cssRules: rect.cssRules,\n                    widget: rect.widget,\n                    cssRelevantRule: 'top'\n                });\n                this.dragLines.push({\n                    x1: rect.x2,\n                    y1: rect.y1,\n                    x2: rect.x2,\n                    y2: rect.y2,\n                    cssRules: rect.cssRules,\n                    widget: rect.widget,\n                    cssRelevantRule: 'right'\n                });\n                this.dragLines.push({\n                    x1: rect.x1,\n                    y1: rect.y2,\n                    x2: rect.x2,\n                    y2: rect.y2,\n                    cssRules: rect.cssRules,\n                    widget: rect.widget,\n                    cssRelevantRule: 'bottom'\n                });\n                this.dragLines.push({\n                    x1: rect.x1,\n                    y1: rect.y1,\n                    x2: rect.x1,\n                    y2: rect.y2,\n                    cssRules: rect.cssRules,\n                    widget: rect.widget,\n                    cssRelevantRule: 'left'\n                });\n            },\n            getClosestLines(x, y) {\n                let closest = [];\n\n                this.dragLines.forEach(line => {\n\n                    let infinite = (line.cssRelevantRule === 'bottom' || line.cssRelevantRule === 'top') && this.mainAxis === 'rows' || (line.cssRelevantRule === 'right' || line.cssRelevantRule === 'left') && this.mainAxis === 'columns';\n                    let dist = this.getPointDistToLine({\n                        x: x,\n                        y: y\n                    }, line, infinite);\n                    if (dist <= 1)\n                        closest.push(line);\n                });\n\n                let filtered = [];\n\n                let top = filter(closest, { cssRelevantRule: 'top' });\n                let bottom = filter(closest, { cssRelevantRule: 'bottom' });\n                let left = filter(closest, { cssRelevantRule: 'left' });\n                let right = filter(closest, { cssRelevantRule: 'right' });\n\n                top.forEach(line => {\n                    let matches = this.mainAxis === 'rows' ? filter(bottom, { y1: line.y1 }) : filter(bottom, {\n                        x1: line.x1,\n                        x2: line.x2\n                    });\n\n                    if (matches.length) {\n                        filtered.push(line);\n                        matches.forEach(match => filtered.push(match));\n                    }\n                });\n                left.forEach(line => {\n                    let matches = this.mainAxis === 'columns' ? filter(right, { x1: line.x1 }) : filter(right, {\n                        y1: line.y1,\n                        y2: line.y2\n                    });\n\n                    if (matches.length) {\n                        filtered.push(line);\n                        matches.forEach(match => filtered.push(match));\n                    }\n                });\n\n                return filtered;\n            },\n            getPointDistToLine(pt, line, infiniteLine) {\n                if (line.x1 === line.x2) {\n                    if (infiniteLine)\n                        return Math.abs(pt.x - line.x1);\n                    else if (pt.y < line.y1)\n                        return this.getPointDistToPoint(pt, {\n                            x: line.x1,\n                            y: line.y1\n                        });\n                    else if (pt.y > line.y2)\n                        return this.getPointDistToPoint(pt, {\n                            x: line.x2,\n                            y: line.y2\n                        });\n                    else\n                        return Math.abs(pt.x - line.x1);\n                } else if (line.y1 === line.y2) {\n                    if (infiniteLine)\n                        return Math.abs(pt.y - line.y1);\n                    if (pt.x < line.x1)\n                        return this.getPointDistToPoint(pt, {\n                            x: line.x1,\n                            y: line.y1\n                        });\n                    else if (pt.x > line.x2)\n                        return this.getPointDistToPoint(pt, {\n                            x: line.x2,\n                            y: line.y2\n                        });\n                    else\n                        return Math.abs(pt.y - line.y1);\n                }\n            },\n            getPointDistToPoint(pt1, pt2) {\n                return Math.sqrt(Math.pow(pt1.x - pt2.x, 2) + Math.pow(pt1.y - pt2.y, 2));\n            },\n            setSubIsOnEdge(onEdge) {\n                let parent = this.options.parent;\n                while (parent) {\n                    parent.subIsOnEdge = onEdge;\n                    parent = parent.options.parent;\n                }\n            },\n            isParentDragging(recurse = false) {\n                let parent = this.options.parent;\n                if (parent)\n                    return parent.draggingLines || parent.isParentDragging(true);\n                else\n                    return recurse ? this.draggingLines : false;\n            },\n            removeWidget(layoutObj) {\n                this._setTransitions(true);\n\n                let rowOrColumnToRemove = null;\n                this.transformedLayout.forEach(rowOrColumn => {\n                    let index = indexOf(rowOrColumn, layoutObj);\n                    if (index !== -1) {\n                        rowOrColumn.splice(index, 1);\n                        if (rowOrColumn.length === 0) {\n                            rowOrColumnToRemove = rowOrColumn;\n                        }\n                    }\n                });\n                if (rowOrColumnToRemove) {\n                    let index = indexOf(this.transformedLayout, rowOrColumnToRemove);\n                    this.transformedLayout.splice(index, 1);\n                }\n                if (this.transformedLayout.length === 0) {\n                    if (this.options.isSub) {\n                        let parentLayoutObj = find(this.options.parent.flatCells, { subLayout: this.layout });\n                        this.options.parent.removeWidget(parentLayoutObj);\n                    }\n                }\n                this.megaRefresh();\n            },\n            normalizeSizes() {\n                let totalSizeMajor = 0;\n                this.transformedLayout.forEach(rowOrColumn => {\n                    let totalSizeMinor = 0;\n                    let totalSizeMajorAdd = 0;\n                    rowOrColumn.forEach(cell => {\n                        totalSizeMinor += this.mainAxis === 'columns' ? cell.percentHeight : cell.percentWidth;\n                        let major = this.mainAxis === 'columns' ? cell.percentWidth : cell.percentHeight;\n                        totalSizeMajorAdd = major > totalSizeMajorAdd ? major : totalSizeMajorAdd;\n                    });\n                    totalSizeMajor += totalSizeMajorAdd;\n                    if (totalSizeMinor !== 100) {\n                        rowOrColumn.forEach(cell => {\n                            if (this.mainAxis === 'columns') {\n                                cell.percentHeight = 100 * cell.percentHeight / totalSizeMinor;\n                            } else {\n                                cell.percentWidth = 100 * cell.percentWidth / totalSizeMinor;\n                            }\n                        });\n                    }\n                });\n                if (totalSizeMajor !== 100) {\n                    this.transformedLayout.forEach(rowOrColumn => {\n                        rowOrColumn.forEach(cell => {\n                            if (this.mainAxis === 'columns') {\n                                cell.percentWidth = 100 * cell.percentWidth / totalSizeMajor;\n                            } else {\n                                cell.percentHeight = 100 * cell.percentHeight / totalSizeMajor;\n                            }\n                        });\n                    });\n                }\n            },\n            splitCell(layoutObj, orientation) {\n                this._setTransitions(true);\n                this.transformedLayout.forEach(rowOrColumn => {\n                    let index = indexOf(rowOrColumn, layoutObj);\n                    if (index !== -1) {\n                        let clone = angular.copy(layoutObj);\n                        if (orientation === 'h' && this.mainAxis === 'rows' || orientation === 'v' && this.mainAxis === 'columns') {\n                            let attr = orientation === 'h' ? 'percentWidth' : 'percentHeight';\n                            layoutObj[attr] /= 2;\n                            clone[attr] /= 2;\n                            rowOrColumn.splice(index + 1, 0, clone);\n                            clone.selectWidgetMode = true;\n                        } else {\n                            delete layoutObj.widget;\n                            layoutObj.subLayout = {};\n                            let axis = this.mainAxis === 'columns' ? 'rows' : 'columns';\n                            layoutObj.subLayout[axis] = [{\n                                    size: '100%',\n                                    cells: ['100% @' + clone.widget],\n                                    new: true\n                                }];\n                        }\n                    }\n                });\n\n                this.megaRefresh();\n            },\n            megaRefresh() {\n                this.updateFlatCells();\n                this.normalizeSizes();\n                this.updateCss();\n                this.updateDragLines();\n                this.loadTemplates().then(() => {\n                    this.$timeout(() => this.compileElements());\n                });\n            },\n            changeWidget(layoutObj) {\n                layoutObj.selectWidgetMode = !layoutObj.selectWidgetMode;\n                this.updateCss();\n            },\n            onWidgetChange(layoutObj) {\n                layoutObj.selectWidgetMode = false;\n                this.templatesLoaded = false;\n                this.megaRefresh();\n            },\n            getWidgetName(key) {\n                return this.widgets[key] ? this.widgets[key].name || key : '';\n            },\n            updateLayoutJSON() {\n                if (!this.transformedLayout)\n                    return;\n\n                this.layoutJSON = {};\n                this.layoutJSON.main = {};\n                this.layoutJSON.main[this.mainAxis] = [];\n                let subLayoutCounter = 0;\n\n                this.transformedLayout.forEach(rowOrColumn => {\n                    let rowOrColumnObject = {};\n                    rowOrColumn.forEach(cell => {\n                        if (!rowOrColumnObject.size)\n                            rowOrColumnObject.size = cell[this.mainAxis === 'columns' ? 'percentWidth' : 'percentHeight'] + '%';\n                        if (!rowOrColumnObject.cells)\n                            rowOrColumnObject.cells = [];\n\n                        let cellString = '';\n                        cellString += cell[this.mainAxis === 'columns' ? 'percentHeight' : 'percentWidth'] + '%';\n                        if (cell.widget && !cell.widget.startsWith('$'))\n                            cellString += ' @' + cell.widget;\n\n                        if (cell.$childLayout) {\n                            cell.$childLayout.updateLayoutJSON();\n\n                            let subName = 'sub' + subLayoutCounter;\n                            subLayoutCounter++;\n\n                            this.layoutJSON[subName] = cell.$childLayout.layoutJSON;\n                            cellString += ' #' + subName;\n                        }\n\n                        rowOrColumnObject.cells.push(cellString);\n                    });\n\n                    this.layoutJSON.main[this.mainAxis].push(rowOrColumnObject);\n                });\n\n            },\n            getWidgetsCount() {\n                return $('.widget-container').length;\n            },\n            _setTransitions(active) {\n                if (active) {\n                    $('.widgets-padder .widget-wrapper').css('transition', `all ${ this.ANIM_DURATION }s ease-out`);\n                } else {\n                    $('.widgets-padder .widget-wrapper').css('transition', 'none');\n                }\n            },\n            _getRootDirective() {\n                if (!this.options.parent)\n                    return this;\n                else\n                    return this.options.parent._getRootDirective();\n            },\n            cleanLayout() {\n                if (!this.transformedLayout)\n                    return;\n\n                // Remove empty layout directives from parent\n                if (!this.transformedLayout.length && this.options.parent) {\n                    let parentLayoutObj = find(this.options.parent.flatCells, { subLayout: this.layout });\n                    this.options.parent.removeWidget(parentLayoutObj);\n                }\n\n                     // In case this directive is a sub and only has one widget in one cell, we move the widget to parent\n                else if (this.transformedLayout.length === 1 && this.transformedLayout[0].length === 1 && this.transformedLayout[0][0].percentHeight === 100 && this.transformedLayout[0][0].percentWidth === 100 && this.options.parent) {\n\n                    let parentLayoutObj = find(this.options.parent.flatCells, { subLayout: this.layout });\n                    let axis = Object.keys(parentLayoutObj.subLayout)[0];\n                    if (!parentLayoutObj.subLayout[axis][0] || parentLayoutObj.subLayout[axis][0] && !parentLayoutObj.subLayout[axis][0].new) {\n                        if (this.transformedLayout[0][0].widget) {\n                            parentLayoutObj.widget = this.transformedLayout[0][0].widget;\n                            delete parentLayoutObj.subLayout;\n                            delete parentLayoutObj.$childLayout;\n                        } else if (this.transformedLayout[0][0].subLayout) {\n                            parentLayoutObj.subLayout = this.transformedLayout[0][0].subLayout;\n                            delete parentLayoutObj.widget;\n                        }\n                    }\n                }\n\n                     // In case this directive is the root and only has one sub in one cell, we move the sub data to this\n                else if (this.transformedLayout.length === 1 && this.transformedLayout[0].length === 1 && this.transformedLayout[0][0].percentHeight === 100 && this.transformedLayout[0][0].percentWidth === 100 && this.transformedLayout[0][0].subLayout && !this.options.parent) {\n\n                    console.log('pre', JSON.stringify(this.layout));\n                    let theSub = this.transformedLayout[0][0].subLayout;\n                    this.layout = theSub;\n                    console.log('post', JSON.stringify(this.layout));\n                    this.transformLayout();\n                    this.cleanLayout();\n\n                }\n\n            },\n            expandPane(layoutObj) {\n                let expanding = this.$expanded = !this.$expanded ? layoutObj : null;\n                this.transformedLayout.forEach(rowOrColumn => {\n                    rowOrColumn.forEach(cell => {\n                        if (expanding) {\n                            cell.dimBeforeExpansion = {\n                                width: cell.percentWidth,\n                                height: cell.percentHeight\n                            };\n                            if (cell === layoutObj) {\n                                cell.percentWidth = cell.percentHeight = 100;\n                            } else {\n                                this.cssRules[cell.cssId].opacity = 0;\n                                let onTheSameRowOrColumn = rowOrColumn.indexOf(layoutObj) !== -1;\n                                if (onTheSameRowOrColumn) {\n                                    cell[this.mainAxis === 'columns' ? 'percentHeight' : 'percentWidth'] = 0;\n                                    cell[this.mainAxis === 'rows' ? 'percentHeight' : 'percentWidth'] = 100;\n                                } else {\n                                    cell[this.mainAxis === 'rows' ? 'percentHeight' : 'percentWidth'] = 0;\n                                    cell[this.mainAxis === 'columns' ? 'percentHeight' : 'percentWidth'] = 100;\n                                }\n                            }\n                        } else {\n                            cell.percentWidth = cell.dimBeforeExpansion.width;\n                            cell.percentHeight = cell.dimBeforeExpansion.height;\n                            delete cell.dimBeforeExpansion;\n                        }\n                    });\n                });\n\n                if (expanding) {\n                    this.$timeout(() => {\n                        this.updateCss();\n                    }, this.ANIM_DURATION * 1000);\n                } else {\n                    this.updateCss();\n                    this.$timeout(() => {\n                        this.transformedLayout.forEach(rowOrColumn => {\n                            rowOrColumn.forEach(cell => {\n                                this.cssRules[cell.cssId].opacity = 1;\n                            });\n                        })\n    ;\n                    }, this.ANIM_DURATION * 1000);\n                }\n\n                if (this.options.parent && this.parentCell) {\n                    this.options.parent.expandPane(this.parentCell);\n                }\n\n                layoutObj.expanded = !layoutObj.expanded;\n\n            }\n\n        }\n    };\n\n</script>\n\n<style scoped lang=\"less\">\n\n\n\n</style>\n","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=script&lang=js&\""],"sourceRoot":""}